# 2024









## Question3

好的，我们来详细解答这份关于一个特定CPU指令集架构的第三大题 (QUESTION 3)。

------

### **中文详细解答**

#### **(a) 这个CPU有多少种可能的操作码？**

根据题目描述，CPU的指令格式中，用于**操作码(Opcode)\**的部分是\**位11到15** 1。



- 这部分总共占用了5个比特位 (15, 14, 13, 12, 11)。
- 5个比特位可以表示的不同组合数量为 2^5。
- 2^5=32。

因此，这个CPU总共有 **32** 种可能的操作码。 



#### **(b) 如果使用立即寻址模式，可以移入目标寄存器的值的范围是多少？**

题目指出，当使用**立即寻址模式(immediate addressing mode)\**时，寻址模式位(10-9)为`01`，并且操作数是存放在\**位0到5**中的一个**6位二进制补码(2's complement)**值 3。



一个n位二进制补码数的表示范围是 −2(n−1) 到 +2(n−1)−1。

- 在这里，n = 6。
- 最小值为：−2(6−1)=−25=−32。
- 最大值为：+2(6−1)−1=25−1=32−1=+31。

所以，可以移入目标寄存器的值的范围是 **-32 到 +31**。

#### **(c) 这个CPU的主内存大小是多少？**

主内存的大小由地址总线的宽度决定。我们需要找到最长的地址格式。

- 寻址模式

  ```
   11
  ```

   描述了如何形成一个完整的地址：“由位0-5左移16位，然后与指令后面的一个16位数值相加” 。

- 位0-5是一个6位的数值。将其左移16位，相当于乘以216，结果是一个22位宽的基地址 (6 + 16 = 22)。

- 这个22位的基地址再与一个16位的偏移量相加，最终的地址至少是22位。这表明CPU可以寻址 222 个不同的内存位置。

- 222=22×220=4×1MB=4MB。

因此，这个CPU的主内存大小是 **4 MB**。

#### **(d) 计算机器码**

**(i) 将十进制数 -12 移入 R5 的机器码是什么？**

- 操作码 (Opcode)

  : MOV指令的操作码是

  ```
  01001
  ```

   5。 (位15-11)

- 寻址模式 (Mode)

  : 立即寻址模式，所以是

  ```
  01
  ```

   6。 (位10-9)

- 目标寄存器 (D Reg)

  : R5，二进制为

  ```
  101
  ```

   7

  。 (位8-6)

- 操作数 (Operand)

  : 十进制-12的6位二进制补码。

  1. +12 的二进制是 `001100`。
  2. 取反得到 `110011`。
  3. 加1得到 `110100`。 (位5-0)

将这些部分组合起来：01001 01 101 110100

按4位分组：0100 1011 0111 0100

转换为十六进制：4 B 7 4

所以，机器码是 **4B74h**。

**(ii) 将R3的内容移到R0的机器码是什么？**

- 

  操作码 (Opcode)

  : MOV，

  ```
  01001
  ```

   8

  。 (位15-11)

- 

  寻址模式 (Mode)

  : 寄存器寻址模式，源操作数在寄存器中，所以是

  ```
  00
  ```

   9

  。 (位10-9)

- 

  目标寄存器 (D Reg)

  : R0，二进制为

  ```
  000
  ```

   10

  。 (位8-6)

- 

  源寄存器 (S Reg)

  : R3，二进制为

  ```
  011
  ```

  。这需要放在位0-5的区域 11

  。我们将其放在最低位，即

  ```
  000011
  ```

  。 (位5-0)

将这些部分组合起来：01001 00 000 000011

按4位分组：0100 1000 0000 0011

转换为十六进制：4 8 0 3

所以，机器码是 **4803h**。

#### **(e) 指令指针在取一条指令后最大会增加多少？**

指令指针(IP)的增量取决于所取指令的长度。我们需要找到最长的指令格式。

- 所有指令的基础长度都是16位（2字节） 12

  。

- 寻址模式

  ```
  11
  ```

  明确指出，在16位的指令之后还跟着一个

  16位的值

   13

  。

- 因此，当使用寻址模式`11`时，指令的总长度为 `16位 (基础指令) + 16位 (后续值) = 32位`。

- 32位等于4字节。

所以，指令指针在取一条指令后，最大会增加 **4字节**。

------

### **English Summary (Key Points)**

**(a) How many possible opcodes are there for this CPU?**

- The opcode is defined by bits 11-15, which is a 5-bit field14

  .

- The number of possible opcodes is 

  25=32

  15

  .

**(b) What is the range of values if immediate addressing mode is used?**

- Immediate mode uses bits 0-5 as a 6-bit 2's complement value16

  .

- The range for a 6-bit 2's complement number is from −2(6−1) to +2(6−1)−1.

- This evaluates to the range **-32 to +31**.

**(c) What is the size of main memory for this CPU?**

- Addressing mode 

  ```
  11
  ```

   forms an address by shifting a 6-bit value left by 16 bits and adding a 16-bit value that follows the instruction17

  .

- This creates a 22-bit address space (6+16=22).

- The memory size is 222 bytes, which is **4 MB**.

**(d) Work out the machine code.**

- (i) Move -12 into R5:

  - Opcode 

    ```
    01001
    ```

     18

    , Mode 

    ```
    01
    ```

    , D-Reg 

    ```
    101
    ```

     (R5), Imm 

    ```
    -12
    ```

     (

    ```
    110100
    ```

    )19

    .

  - Binary: `0100101101110100`.

  - Hex: **4B74h**.

- (ii) Move contents of R3 to R0:

  - Opcode 

    ```
    01001
    ```

     20

    , Mode 

    ```
    00
    ```

    , D-Reg 

    ```
    000
    ```

     (R0), S-Reg 

    ```
    011
    ```

     (R3)21

    .

  - Binary: `0100100000000011`.

  - Hex: **4803h**.

**(e) What is the maximum increment that the instruction pointer will undergo after fetching an instruction?**

- The basic instruction length is 16 bits22

  .

- Addressing mode 

  ```
  11
  ```

   adds a 16-bit value that follows the instruction23

  .

- The maximum instruction length is `16 + 16 = 32` bits.

- The maximum increment is 32 bits, which is **4 bytes**.



## Question4



好的，我们来详细解答这份关于一个汇编语言子程序 (Subroutine) 的第四大题 (QUESTION 4)。

------

### **中文详细解答**

该题目围绕一个名为 `Print` 的子程序，这个子程序的作用是将 `AX` 寄存器中的一个十进制数以数字字符的形式显示在屏幕上。

#### **(a) 如果AX包含十进制数12,345，子程序会打印出什么？**

我们来追踪子程序的执行流程：

1. 第一个循环 (`next`)

   :

   - 这个循环通过连续将 

     ```
     AX
     ```

      的值除以10，来分离出每一位的十进制数字。 11

   - 

     ```
     div bx
     ```

      指令（

     ```
     bx
     ```

     =10）将

     ```
     DX:AX
     ```

     中的32位数除以10，商存入

     ```
     AX
     ```

     ，余数存入

     ```
     DX
     ```

     。 22

   - 每次得到的余数就是当前数字的个位。例如 `12345 / 10`，商是 `1234`，余数是 `5`。

   - 

     ```
     or dx, 030h
     ```

      将这个余数（0-9）转换成对应的ASCII字符（'0'-'9'）。 33

   - 

     ```
     push dx
     ```

      将这个ASCII字符压入堆栈。 44

   - 这个循环固定执行5次。 55

2. 压栈顺序

   :

   - 第一次循环，余数是5，`'5'`被压入堆栈。
   - 第二次循环，余数是4，`'4'`被压入堆栈。
   - 第三次循环，余数是3，`'3'`被压入堆栈。
   - 第四次循环，余数是2，`'2'`被压入堆栈。
   - 第五次循环，余数是1，`'1'`被压入堆栈。
   - 此时堆栈从顶到底的内容是：`'1'`, `'2'`, `'3'`, `'4'`, `'5'`。

3. 第二个循环 (`nxout`)

   :

   - 这个循环从堆栈中弹出（pop）字符并打印。 66
   - 堆栈是“后进先出”（FILO）的，所以最先被弹出和打印的是最后压入的 `'1'`。
   - 打印顺序将是：1, 2, 3, 4, 5。

因此，屏幕上会打印出 **12345**。 77



#### **(b) 如果AX包含十进制数678，子程序会打印出什么？**

同样地，我们追踪执行流程：

1. 第一个循环 (`next`)

   :

   - `678 / 10` -> 商 `67`，余 `8`。压入 `'8'`。
   - `67 / 10` -> 商 `6`，余 `7`。压入 `'7'`。
   - `6 / 10` -> 商 `0`，余 `6`。压入 `'6'`。
   - 由于循环固定执行5次，接下来的两次除法都是 `0 / 10`。
   - `0 / 10` -> 商 `0`，余 `0`。压入 `'0'`。
   - `0 / 10` -> 商 `0`，余 `0`。压入 `'0'`。

2. **压栈顺序**: 堆栈从顶到底的内容是：`'0'`, `'0'`, `'6'`, `'7'`, `'8'`。

3. **第二个循环 (`nxout`)**: 依次弹出并打印。

因此，屏幕上会打印出 **00678**。

#### **(c) 如果AX包含十六进制数13AC，子程序会打印出什么？**

子程序是为打印**十进制**数而设计的。所以我们必须先将十六进制的 `13AC` 转换为十进制数。

- `13AC (hex)` = 1times163+3times162+10times161+12times160
- =1times4096+3times256+160+12
- =4096+768+160+12=5036 (十进制)

现在问题变成了“如果AX包含十进制数5036，会打印出什么？”。根据(b)的逻辑，为了凑齐5位数，程序会在前面补一个0。

- 压栈的顺序将是：`'6'`, `'3'`, `'0'`, `'5'`, `'0'`。
- 打印的顺序将是：`0`, `5`, `0`, `3`, `6`。

因此，屏幕上会打印出 **05036**。

#### **(d) 学生将`mov bx,10`改为`mov bx,16`后，若AX为13ACh，会显示什么？**

这个修改将除数从10改为了16，意味着子程序现在会尝试按**十六进制**来分离数字。但ASCII转换部分 `or dx, 030h` 并没有被相应修改。

1. 第一个循环 (`next`)

    with 

   ```
   AX = 13ACh
   ```

   , 

   ```
   bx = 16
   ```

    (

   ```
   10h
   ```

   ):

   - `13ACh / 10h` -> 商 `13Ah`，余 `0Ch` (12)。`0Ch | 30h = 3Ch`。压入 `'<'` 字符。
   - `13Ah / 10h` -> 商 `13h`，余 `0Ah` (10)。`0Ah | 30h = 3Ah`。压入 `':'` 字符。
   - `13h / 10h` -> 商 `1h`，余 `3h`。`3h | 30h = 33h`。压入 `'3'` 字符。
   - `1h / 10h` -> 商 `0h`，余 `1h`。`1h | 30h = 31h`。压入 `'1'` 字符。
   - `0h / 10h` -> 商 `0h`，余 `0h`。`0h | 30h = 30h`。压入 `'0'` 字符。

2. **压栈顺序**: 堆栈从顶到底的内容是：`'0'`, `'1'`, `'3'`, `':'`, `'<'`。

3. **第二个循环 (`nxout`)**: 依次弹出并打印。

因此，屏幕上会显示 **013:<**。

#### **(e) 如何修改代码以正确显示十六进制内容？**

为了修正(d)中出现的问题，我们需要在打印前对那些大于9的十六进制数字（A-F）的ASCII码进行校正。在`nxout`循环中，标记为`<<- HERE`的位置是最佳修改点。

此时`dx`中已经弹出了一个字符（例如`:`，它的ASCII码是`3Ah`）。我们需要检查它是否是错误的，如果是，就修正它。

- `0-9`的ASCII码是`30h-39h`，是正确的。
- `10-15`的错误ASCII码是`3Ah-3Fh`。
- 正确的`A-F`的ASCII码是`41h-46h`。
- 它们之间正好相差7 (`41h - 3Ah = 7`)。

在`<<- HERE`位置添加如下代码：

Code snippet

```
        cmp dl, '9'     ; 将弹出的字符与'9'比较
        jle print_it    ; 如果小于或等于'9'，说明是正确的数字0-9，直接跳转去打印
        add dl, 7       ; 如果大于'9'，说明是A-F的错误表示，给它加上7来修正
print_it:
        mov ah, 02h     ; 这行代码已经在原始代码中
        int 021h        ; 这行代码也已经在原始代码中
```

这样修改后，当弹出的字符是`:`(`3Ah`)时，它会大于`'9'`，于是加上7变为`41h`，也就是正确的`'A'`。这样就能正确显示所有十六进制数字了。

------

### **English Summary (Key Points)**

**(a) If AX contains 12,345 decimal, what will be printed?**

- The subroutine separates decimal digits by repeatedly dividing by 10 and pushing the remainder's ASCII value onto the stack. 8

- The digits are pushed in reverse order (5, 4, 3, 2, 1).

- The second loop pops and prints them, resulting in the correct order.

- 

  Output: 12345

   99

**(b) If AX contains 678 decimal, what will be printed?**

- The loop runs a fixed 5 times. 1010
- Digits 8, 7, 6 are pushed, followed by two 0s to make up 5 digits.
- **Output: 00678**

**(c) If AX contains 13AC hexadecimal, what will be printed?**

- The subroutine is for decimal printing, so `13ACh` must be converted to decimal first: `13ACh = 5036` decimal.
- The program will print this 4-digit number as a 5-digit number by padding a leading zero.
- **Output: 05036**

**(d) After changing `mov bx,10` to `mov bx,16`, what is displayed for `13ACh`?**

- The program now divides by 16, separating hex digits. 

- The ASCII conversion 

  ```
  or dx, 030h
  ```

   is now incorrect for digits A-F (10-15). 

- Remainders 12 (C) and 10 (A) are converted to ASCII `<` and `:` respectively.

- Output: 013:&lt;

   

**(e) How to modify the code to print correct hexadecimal?**

- An adjustment is needed for characters 'A'-'F' after popping from the stack and before printing (at the 

  ```
  HERE
  ```

   location).

- The logic should check if the popped character's ASCII value is greater than '9'. If it is, 7 should be added to correct it.

- Code to add at `HERE`:

  

  ```
  cmp dl, '9'
  jle print_it
  add dl, 7
  print_it:
  ```

## Question5



好的，我们来详细解答这份2023-2024学年Maynooth大学计算机体系结构2 (CS253FZ) 试卷的第五大题 (QUESTION 5)。

------

### **中文详细解答**

#### **(a) 数据段分析**

(i) 存储这些数据用了多少字节？ 1

我们需要计算每个数据定义所占用的字节数并将它们相加。

- 

  ```
  num db 2,4,6
  ```

  ：

  ```
  db
  ```

   (define byte) 定义字节。这里有3个数字，所以占用 

  3字节

  。 2

- 

  ```
  num2 dw 0345h
  ```

  ：

  ```
  dw
  ```

   (define word) 定义字。一个字在x86架构中是2个字节，所以占用 

  2字节

  。 3

- 

  ```
  string db "DOG"
  ```

  ：

  ```
  db
  ```

   定义字节。字符串 "DOG" 包含3个ASCII字符，所以占用 

  3字节

  。 4

- 

  ```
  finum dd 2.625
  ```

  ：

  ```
  dd
  ```

   (define doubleword) 定义双字。一个双字是4个字节，所以占用 

  4字节

  。 5

总字节数 = `3 + 2 + 3 + 4 = 12` 字节。

(ii) 显示指定内存位置的内容 6

num 标签指向内存位置 10000h 7，并且x86架构使用小端模式 (little-endian) 8。

- num (db 2,4,6)

  ：从

  ```
  10000h
  ```

  开始，顺序存放。

  - `10000h`: `02h`
  - `10001h`: `04h`
  - `10002h`: `06h`

- num2 (dw 0345h)

  ：从

  ```
  10003h
  ```

  开始。小端模式下，低位字节存放在低地址。

  - `10003h`: `45h` (低位字节)
  - `10004h`: `03h` (高位字节)

- string (db "DOG")

  ：从

  ```
  10005h
  ```

  开始。存放每个字符的ASCII码。

  - 'D' = 

    ```
    44h
    ```

     9

  - 'O' = 

    ```
    4Fh
    ```

     10

  - 'G' = 

    ```
    47h
    ```

     11

  - `10005h`: `44h`

  - `10006h`: `4Fh`

  - `10007h`: `47h`

- finum (dd 2.625)

  ：从

  ```
  10008h
  ```

  开始。需要将其转换为32位IEEE 754浮点数格式。

  - 转换`2.625`：符号为正(0)；二进制为`10.101`；规格化为`1.0101 x 2^1`。指数为`1+127=128` (`10000000b`)；尾数为`0101`...。
  - 组合后为 `0 10000000 01010000...` -> `40280000h`。
  - 小端模式存储：
    - `10008h`: `00h`
    - `10009h`: `00h`
    - `1000Ah`: `28h`
    - `1000Bh`: `40h`

**内存内容表:**

| **内存地址 (Hex)** | **存储内容 (Hex)** |
| ------------------ | ------------------ |
| 1000Bh             | 40                 |
| 1000Ah             | 28                 |
| 10009h             | 00                 |
| **10008h**         | **00**             |
| 10007h             | 47                 |
| 10006h             | 4F                 |
| **10005h**         | **44**             |
| 10004h             | 03                 |
| **10003h**         | **45**             |
| 10002h             | 06                 |
| 10001h             | 04                 |
| **10000h**         | **02**             |

#### **(b) 堆栈的FILO顺序**

(i) 简要解释FILO的含义 12

FILO是“First-In, Last-Out”的缩写，即“先进后出”。它描述了一种数据存取方式：最先被存入（或压入堆栈）的数据，要等到所有在它之后存入的数据都被取出后，才能被取出。这个原则就像一叠盘子，你总是先用最上面（最后放上去）的那个盘子。

(ii) 简要解释为什么它特别适合存储中断程序的返回地址 13

堆栈的FILO特性完美地匹配了中断嵌套的执行模式。

- 当一个中断（如中断A）发生时，主程序的返回地址被压入堆栈。
- 如果在执行中断A的过程中，一个更高优先级的中断B发生，那么中断A的返回地址会被压入堆栈，位于主程序返回地址的“上方”。
- 当中断B执行完毕后，根据FILO原则，它会从堆栈顶部弹出自己的返回地址（即中断A中的地址），正确地返回到中断A中继续执行。
- 当中断A最终执行完毕后，它再从堆栈顶部弹出属于它的返回地址（即主程序中的地址），正确地返回主程序。 FILO确保了无论中断嵌套多少层，返回顺序总是与进入顺序相反，保证了程序能够一层层地正确返回，不会出错。

#### **(c) 向量处理和流水线之间的主要区别** 14

向量处理（Vector Processing）和流水线（Pipelining）都是加速计算的方法，但它们的原理和应用层面不同。 15



- **流水线 (Pipelining)**：是一种**指令级并行**技术。它将一条指令的执行过程分解为多个阶段（如取指、译码、执行），然后让不同指令的不同阶段重叠执行。它加速的是一个**不同指令**组成的标量指令流的处理速度。
- **向量处理 (Vector Processing / SIMD)**：是一种**数据级并行**技术。它通过一条指令同时对多个数据元素（一个向量或数组）执行**相同的操作**。它加速的是对一个大型数据集执行重复操作的速度。

**主要区别**：流水线是通过重叠执行**不同的指令**来提速；向量处理是通过一次性对**不同的数据**执行**相同的指令**来提速。

#### **(d) 寻找打印屏幕中断服务程序的地址**

题目要求找到打印屏幕中断（中断号为5）服务程序的完整起始地址。 16



1. **定位中断向量**：在x86的中断向量表（IVT）中，每个中断向量占用4个字节。中断号为 `n` 的向量地址是 `n * 4`。

2. **计算地址**：对于中断号5，其在IVT中的位置是 `5 * 4 = 20` (十进制)，即 `14h` (十六进制)。

3. 

   查找向量表

   ：我们需要在给定的向量表 17

    中查找包含地址

   ```
   14h
   ```

   的条目。

   - 地址范围 

     ```
     14-17
     ```

      对应中断号5。 18

   - 该地址范围的内容是 

     ```
     F000:FF54
     ```

     。 19

      这是

     ```
     CS:IP
     ```

     格式的逻辑地址。

4. 计算物理地址

   ：物理地址的计算公式是 

   ```
   (段地址 * 16) + 偏移地址
   ```

   。

   - 物理地址 = `(F000h * 10h) + FF54h`
   - `= F0000h + FF54h`
   - `= FFF54h`

因此，打印屏幕中断服务程序的完整起始地址是 **FFF54h**。

------

### **English Summary (Key Points)**

**(a) Data Section Analysis**

- 

  (i) How many bytes are used?

   20

  - 

    ```
    num db 2,4,6
    ```

    : 3 bytes 21

  - 

    ```
    num2 dw 0345h
    ```

    : 2 bytes 22

  - 

    ```
    string db "DOG"
    ```

    : 3 bytes 23

  - 

    ```
    finum dd 2.625
    ```

    : 4 bytes 24

  - Total: **12 bytes**.

- (ii) Show memory contents:

  - Starting at 

    ```
    10000h
    ```

     and using little-endian convention25

    , the memory is populated as follows:

    - `10000h-10002h`: `02 04 06`

    - `10003h-10004h`: `45 03` (little-endian for `0345h`)

    - 

      ```
      10005h-10007h
      ```

      : 

      ```
      44 4F 47
      ```

       (ASCII for "DOG") 26

    - `10008h-1000Bh`: `00 00 28 40` (little-endian for `2.625` as `40280000h`)

**(b) The FILO order of a stack**

- 

  (i) What is FILO?

  : FILO stands for 

  First-In, Last-Out

  27

  ; the last item pushed onto the stack is the first one to be popped off.

- 

  (ii) Why is it suited for interrupt routines?

  : Its FILO nature perfectly manages 

  nested interrupts

  . 28

   When one interrupt preempts another, the return addresses are stacked in the correct order. 

  As each interrupt routine finishes, it pops its own return address from the top of the stack, ensuring a correct, sequential return through all nested levels. 29

**(c) Main difference between vector processing and pipelining** 30



- 

  Pipelining

  : An instruction-level parallelism technique that overlaps the execution stages of a sequence of 

  different instructions

  . 31

- 

  Vector Processing

  : A data-level parallelism (SIMD) technique where a single instruction performs the 

  same operation

   on multiple data elements at once. 32

- **Key Difference**: Pipelining speeds up a stream of *different instructions*; vector processing speeds up the *same instruction* on different data.

**(d) Find the start address of the print screen ISR**

- The print screen interrupt has interrupt number 5. 33

- Its location in the Interrupt Vector Table (IVT) is at byte offset 

  ```
  5 * 4 = 20
  ```

   (decimal), which is 

  ```
  14h
  ```

  . 34

- The provided table shows that the content at address range 

  ```
  14-17
  ```

   is 

  ```
  F000:FF54
  ```

  . 35

- The full physical address is calculated as `(Segment * 16) + Offset`.

- Address = `(F000h * 10h) + FF54h` = **FFF54h**.