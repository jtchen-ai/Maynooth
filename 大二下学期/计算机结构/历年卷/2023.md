# 2023



## Question1

好的，我们来逐一解析这份2022-2023学年Maynooth大学计算机体系结构2 (CS253FZ) 试卷的第一大题 (QUESTION 1)。

------

### **(a) 匹配项解析**

此部分要求将术语与代码中的标号匹配。

- (i) A -> 汇编器指令 (assembler directives) 1

  A部分包含如.model, .stack, .data, .code等，这些不是CPU执行的指令，而是指导汇编器如何组织程序的命令，告诉汇编器关于内存模型、堆栈、数据段和代码段的信息。

- (ii) B -> 偏移量 (offset) 2

  B部分是代码左侧的数字序列（如0017, 0019），代表了指令或数据相对于代码段起始位置的地址偏移量。

- (iii) C -> 操作数 (operands) 3

  C部分是指令的操作对象（如ah, 08h中的08h，al, 13中的13）。它们是指令要处理的数据或地址。

- (iv) D -> 操作码 (opcodes) 4

  D部分是指令的机器语言表示（如84 08, CD 21）。这是CPU能够直接识别和执行的十六进制代码。

- (v) E -> 助记符 (mnemonics) 5

  E部分是指令的人类可读的符号表示（如mov, int, cmp）。它们是操作码的助记符号，方便程序员编写代码。

------

### **(b) D项和E项的主要区别**

D项（操作码）和E项（助记符）代表的是同一条指令的两种不同表现形式。 6



- 

  D项 (Opcodes)

  ：是

  机器码

  （Machine Code）。 7

  它是指令的最终二进制或十六进制形式，是CPU能够直接理解和执行的格式。 8

- 

  E项 (Mnemonics)

  ：是

  汇编语言

  （Assembly Language）。 9

  它是使用人类可读的助记符号来表示指令，方便程序员编写和阅读。 10

**主要区别**：**助记符（E）是为程序员服务的，而操作码（D）是为CPU服务的。** 汇编器(Assembler)的工作就是将程序员写的助记符（E）和操作数（C）翻译成CPU能懂的操作码（D）。

------

### **(c) 程序运行时屏幕上会显示什么**

该程序的功能是接收键盘输入，检查字符是否为大写字母（'A'到'Z'），如果是，则将其转换为小写字母并输出。 11



1. 检查范围：

   ```
   cmp al, 41h
   ```

    (

   ```
   'A') 和 
   ```

   ```
   cmp al, 5Ah
   ```

    (

   ```
   'Z'
   ```

   ) 定义了检查的范围是'A'到'Z'。 1212

2. 

   转换操作

   ：如果字符在范围内，

   ```
   add al, 20h
   ```

    这条指令会将其ASCII码加32，从而将大写字母转换为小写字母。 13

3. 

   输入字符串

   ：

   ```
   abc123ABC890XYZpqr
   ```

    

我们来分析输入流：

- `abc123`：不是大写字母，不满足`jl next`的反向条件（即`jge 'A'`）和`jg next`的条件（即`jle 'Z'`），所以直接跳过输出。
- `ABC`：是大写字母，在'A'和'Z'之间。它们会被转换为`abc`并显示在屏幕上。
- `890`：不是大写字母，跳过。
- `XYZ`：是大写字母，会被转换为`xyz`并显示在屏幕上。
- `pqr`：不是大写字母，跳过。

因此，屏幕上最终会显示：**abcxyz**

------

### **(d) 确定XX和YY的十六进制值**

这部分考察相对跳转地址的计算。 



- **计算XX (je done)**

  - 

    ```
    je done
    ```

    指令位于偏移地址

    ```
    001D
    ```

    。 

  - 跳转的目标地址是

    ```
    done
    ```

    ，其偏移地址为

    ```
    0031
    ```

    。 

  - 相对跳转的偏移量计算公式为：`目标地址 - 当前指令的下一条指令地址`。

  - 当前指令的下一条指令地址是`001F`。

  - 偏移量 = `0031h - 001Fh = 12h`。

  - 所以 **XX = 12h**。

- **计算YY (jg next)**

  - 

    ```
    jg next
    ```

    指令位于偏移地址

    ```
    0025
    ```

    。 1818

  - 跳转的目标地址是

    ```
    next
    ```

    ，其偏移地址为

    ```
    0017
    ```

    。 1919

  - 当前指令的下一条指令地址是`0027`。

  - 偏移量 = `0017h - 0027h = -10h`。

  - 这是一个向后跳转，负数用补码表示。-10h (十进制-16) 的8位补码是 `F0h`。

  - 所以 **YY = F0h**。

------

### **(e) 计算指令的起始物理地址**

物理地址的计算公式为：`物理地址 = (段地址 * 16) + 偏移地址`。 2020



- 段地址 (CS) = 

  ```
  12EFh
  ```

  

- 偏移地址 (IP) for 

  ```
  cmp al,13
  ```

   = 

  ```
  001Bh
  ```

计算过程：

1. 将段地址左移一位（即乘以16或10h）：`12EFh * 10h = 12EF0h`。
2. 加上偏移地址：`12EF0h + 001Bh = 12F0Bh`。

因此，该指令在主内存中的起始地址是 **12F0Bh**。

------

### **(f) 计算主内存大小**

主内存的大小由地址总线的位数决定。 23



- 地址总线位数 = 32位 24
- 可寻址的内存空间 = 2 ^ (地址总线位数)
- 计算：`2^32` 字节

换算单位：

- `2^10` = 1 KB
- `2^20` = 1 MB
- `2^30` = 1 GB
- `2^32 = 2^2 * 2^30 = 4 * 1 GB = 4 GB`

所以，主内存的大小是 **4 GB**。

------

### **(g) SSD相对于HDD的优缺点**

- **SSD的两个优点**： 25

  

  

  1. **更快的速度**：SSD没有移动部件，数据访问是电子式的，因此其读写速度（特别是随机读写）远快于需要物理寻道和旋转磁盘的HDD。
  2. **更高的耐用性和可靠性**：由于没有机械部件，SSD更能抵抗物理冲击、振动和跌落，更适合用于笔记本电脑等移动设备。

- **SSD的两个缺点**： 26

  

  

  1. **更高的成本**：以每GB的单位成本来衡量，SSD通常比HDD更昂贵。
  2. **有限的写入寿命**：SSD的闪存单元有有限的擦写次数。尽管现代SSD通过磨损均衡等技术大大延长了寿命，但理论上其写入寿命仍然是有限的，而HDD理论上可以无限次读写。

------

### **(h) 解释为什么在ISR中要将寄存器推入堆栈**

在进入中断服务程序 (ISR) 前将寄存器内容推入堆栈，并在ISR结束时恢复它们，这是为了**保存和恢复程序的上下文 (Context)**。 27



**原因**：

1. **中断的不可预测性**：中断可能在主程序的任何时刻发生。此时，主程序正在使用CPU的寄存器（如AX, BX等）进行计算。
2. **共享资源**：ISR本身也需要使用这些CPU寄存器来完成自己的任务。
3. **防止数据破坏**：如果不先保存主程序的寄存器值，ISR就会用自己的计算结果覆盖掉它们。当中断结束后返回主程序时，主程序会使用被破坏了的、错误的数据继续运行，导致程序崩溃或产生无法预料的结果。

通过在进入ISR时将寄存器压栈，在退出时弹栈，可以确保ISR对主程序来说是“透明的”，主程序感觉不到自己曾被打断过，能够从断点处无缝、正确地继续执行。 28



------

------

### **English Summary (Key Points)**

**(a) Matching Terms**

- 

  (i) A -> assembler directives

  : Commands for the assembler (e.g., 

  ```
  .model
  ```

  , 

  ```
  .code
  ```

  ). 29

- 

  (ii) B -> offset

  : Address relative to the start of a segment. 30

- 

  (iii) C -> operands

  : Data or addresses an instruction operates on. 31

- 

  (iv) D -> opcodes

  : Machine-readable hexadecimal instruction code. 32

- 

  (v) E -> mnemonics

  : Human-readable instruction names (e.g., 

  ```
  mov
  ```

  , 

  ```
  cmp
  ```

  ). 33

**(b) Difference between D (opcodes) and E (mnemonics)**

- 

  D (Opcodes)

  : Machine code for the CPU. 34

- 

  E (Mnemonics)

  : Assembly language for the programmer. 35

- The assembler translates human-readable mnemonics (E) into machine-executable opcodes (D).



考点：汇编语言

**(c) What appears on the screen**

- The program checks for uppercase letters ('A'-'Z') and converts them to lowercase for output. 36

- Input: 

  ```
  abc123ABC890XYZpqr
  ```

   37

- Output: **abcxyz**



考点： 复数转换为 8-bit two's complement ，认出偏移位置

**(d) Hexadecimal values of XX and YY** 



- **XX (`je done`)**: Jump offset = `target (0031h) - next_instruction (001Fh)` = `12h`. So, **XX = 12h**.
- **YY (`jg next`)**: Jump offset = `target (0017h) - next_instruction (0027h)` = `-10h`. The 8-bit two's complement of -16 is `F0h`. So, **YY = F0h**.



考点：Physical Address = (CS * 10h) + IP. 

**(e) Starting address of instruction**

- Formula: Physical Address = (CS * 10h) + IP. 

- CS = 

  ```
  12EFh
  ```

  , IP = 

  ```
  001Bh
  ```

  . 40404040

- Address = `12EF0h + 001Bh` = **12F0Bh**.

**(f) Size of main memory**

- With a 32-bit address bus, the memory size is 2^32 bytes. 41
- 2^32 bytes = **4 Gigabytes (GB)**.



考点 ：SSD vs. HDD

**(g) SSD vs. HDD**

- 

  SSD Advantages: 

  1. **Faster Speed**: No moving parts, faster data access.
  2. **Higher Durability**: More resistant to physical shock.

- 

  SSD Disadvantages: 43

  1. **Higher Cost**: More expensive per gigabyte.
  2. **Limited Write Lifespan**: Flash memory cells have a finite number of write cycles.

**(h) Why push registers onto stack in an ISR**

- To preserve the contextof the interrupted program. 
- The ISR needs to use the same registers as the main program. 
- Pushing registers saves the main program's data before the ISR uses them, and popping restores the data after the ISR finishes. This prevents data corruption and allows the main program to resume correctly. 

## Question2



**(a) Obtain an expression relating D, the desired delay in machine cycles, in terms of V, B, G, W and N.**

The total delay `D` is the sum of the cycles for each part of the routine:

- 

  Overhead (V):

   The 

  ```
  mov cx, N
  ```

   instruction is executed once at the beginning1

  . This contributes 

  ```
  V
  ```

   cycles.

- 

  Loop Body:

   The loop contains three 

  ```
  nop
  ```

   instructions, each taking 

  ```
  W
  ```

   cycles2

  . So one pass through the loop's body takes 

  ```
  3 * W
  ```

   cycles.

- Looping Logic:

   The 

  ```
  loop waste
  ```

   instruction has two different cycle counts:

  - For the first 

    ```
    N-1
    ```

     iterations, the loop jumps back, taking 

    ```
    B
    ```

     cycles each time3

    .

  - On the final (Nth) iteration, the loop condition (

    ```
    cx
    ```

    =0) is met, and it "gets out," taking 

    ```
    G
    ```

     cycles4

    .

Combining these parts:

- Cycles for the first `N-1` loops = `(N-1) * (3*W + B)`
- Cycles for the final loop = `3*W + G`

The total delay D is the sum of the overhead and all loop iterations:

D = V + (N-1) * (3*W + B) + (3*W + G)

This can be simplified:

D = V + (N-1) * (3*W) + (N-1) * B + 3*W + G

D = V + N*3*W - 3*W + (N-1)*B + 3*W + G

D = V + N * (3*W) + N*B - B + G

D = V - B + G + N * (3*W + B)

Let's use the first, un-simplified formula as it more clearly represents the process.

D = V + (N - 1) * (3*W + B) + 3*W + G

Given W=3 cycles, B=17 cycles:

D = V + (N - 1) * (3*3 + 17) + 3*3 + G

D = V + (N - 1) * (9 + 17) + 9 + G

D = V + (N - 1) * 26 + 9 + G

Since the question asks for the expression in terms of the variables, the most direct expression is:

D = V + N * (3*W) + (N-1)*B + G or D = V + (N-1)(3W+B) + 3W + G

**(b) If N is set to be 30,000, what will be the delay generated in terms of machine cycles?**

Using the derived formula and substituting the given values:

- N = 30,000 5
- V = 4 cycles 6
- W = 3 cycles 7
- B = 17 cycles 8
- G = 5 cycles 9

D = V + (N - 1) * (3*W + B) + 3*W + G

D = 4 + (30,000 - 1) * (3*3 + 17) + 3*3 + 5

D = 4 + (29,999) * (9 + 17) + 9 + 5

D = 4 + (29,999) * (26) + 14

D = 4 + 779,974 + 14

D = 780,000 - 26 + 18

D = 779,992

D = 18 + 779974 = 779992

D = 4 + 779,974 + 14 = 779,992

Let's re-calculate to be certain:

D = 4 + (29999 * 26) + (9+5)

D = 4 + 779974 + 14

D = 779992

The delay will be **779,992 machine cycles**.

**(c) Suppose the CPU is running at 100MHz, and a delay of 500 ms is required, what should be the value of N?** 10



First, calculate the total number of machine cycles required for the delay.

- CPU speed = 100 MHz = 100,000,000 cycles/second 11
- Required delay = 500 ms = 0.5 seconds 12
- Total cycles `D` = 100,000,000 cycles/s * 0.5 s = 50,000,000 cycles.

Now, use the delay formula from part (a) and solve for N.

D = V + (N - 1) * (3*W + B) + 3*W + G

50,000,000 = 4 + (N - 1) * (26) + 9 + 5

50,000,000 = 18 + (N - 1) * 26

49,999,982 = (N - 1) * 26

N - 1 = 49,999,982 / 26

N - 1 ≈ 1,923,076.23

N ≈ 1,923,077.23

The value for N should be approximately **1,923,077**.

**(d) What is the maximum delay in machine cycles that can be generated by the piece of code shown above?**

The `loop` instruction uses the 16-bit `CX` register as its counter. The maximum value that can be placed in a 16-bit register is 65,535 (`FFFFh`). However, the `loop` instruction decrements `CX` and then checks if it is zero. If you initialize `CX` to 0, it will be decremented to 65,535 (`FFFFh`), and the loop will run 65,536 times. This is the largest possible value for N.

- Maximum N = 65,536

Now, substitute this value into the delay formula:

D_max = V + (N_max - 1) * (3*W + B) + 3*W + G

D_max = 4 + (65,536 - 1) * (26) + 9 + 5

D_max = 18 + (65,535) * 26

D_max = 18 + 1,703,910

D_max = 1,703,928

The maximum delay that can be generated is **1,703,928 machine cycles**.



## Question3



; (a) Set loop counter bx to 4 for 4 nibbles
;     Clear carry for rotate
    mov bx, 4       ; Set outer loop counter for 4 hex digits
    clc             ; Clear Carry Flag before first rotation

; (b) Again: set loop counter to 4 for 4 bits in nibble
;     Clear dl for output
Again:
    mov cx, 4       ; Set inner loop counter for 4 bits
    mov dl, 0       ; Clear dl, it will hold the nibble value (0-15)

; (c) Nib: rotate through carry
;     highest nibble of ax to lowest nibble of bx
Nib:
    shl ax, 1       ; Shift highest bit of AX into the Carry Flag
    adc dl, dl      ; Equivalent to (dl = dl * 2 + Carry). Builds the nibble in dl.
    loop Nib        ; Loop 4 times to get 4 bits

; (d) Check if nibble is 0-9
;     If so, go to deci
;     Otherwise adjust for 'A' to 'F'
    cmp dl, 9       ; Compare the nibble value with 9
    jle Deci        ; If it's 0-9, jump to Deci for ASCII conversion
    add dl, 7       ; If it's 10-15, add 7 as adjustment for letters 'A'-'F'

; (e) Deci: change value in dl to ASCII
;     Save ax
;     Output dl
;     Retrieve ax
;     Jump back to again
Deci:
    add dl, 30h     ; Convert the value (0-15) to its ASCII character representation ('0'-'9', 'A'-'F')
    
    push ax         ; Save AX because INT 21h might change it
    mov ah, 02h     ; DOS function: Display character
    int 21h         ; Call DOS to print the character in DL
    pop ax          ; Restore AX
    
    loop Again      ; Decrement BX and jump to Again if BX is not zero





## Question4



好的，我们来详细解答这份关于MOSFET和CMOS逻辑门的问题。

------

### **中文解析**

#### **(a) 绘制一个n沟道MOSFET的结构图，并简要解释它如何作为压控开关使用。(6分)**

n沟道MOSFET结构图描述

(由于无法直接绘图，此处提供详细的文字描述供您绘制)

1. **衬底 (Substrate)**：首先是一块P型掺杂的硅作为基座。
2. **源极/漏极 (Source/Drain)**：在P型衬底上表面的左右两侧，通过扩散或离子注入形成两个高浓度N型掺杂区域，分别称为源极和漏极。
3. **沟道区 (Channel Region)**：位于源极和漏极之间的P型衬底区域。
4. **栅极氧化层 (Gate Oxide)**：在沟道区的正上方，覆盖着一层极薄的二氧化硅(SiO₂)绝缘层。
5. **栅极 (Gate)**：在氧化层的上方，是一层导电材料（通常是金属或多晶硅），称为栅极。
6. **电极引出**：从栅极、源极和漏极分别引出金属电极，用于连接外部电路。

作为压控开关的工作原理

MOSFET作为“电压控制器件”的核心在于其栅极电压(Gate Voltage)可以控制源极(Source)和漏极(Drain)之间的导通与关断。

- **关断状态 (OFF / 开关断开)**：当栅极与源极之间的电压 VGS 为零或为负时，源极和漏极之间是两个背对背的PN结，不存在导电沟道。因此，没有电流可以从漏极流向源极。此时，开关处于“断开”状态。
- **导通状态 (ON / 开关闭合)**：当施加一个足够大的正电压到栅极 (即 VGS 大于一个称为**阈值电压 Vth** 的值) 时，栅极的正电场会穿透薄的氧化层，将P型衬底中的少数载流子（电子）吸引到氧化层下方。当这些电子积累到一定浓度时，它们会在源极和漏极之间形成一个导电的**N型沟道 (n-channel)**。这个沟道就像一座桥，将原本被隔开的源极和漏极连接起来，允许电流自由流过。此时，开关处于“闭合”状态。

**结论**：因为栅极上的电压直接控制了导电沟道的形成与否，从而控制了电流的通断，所以MOSFET可以被用作一个**压控开关**。

------

#### **(b) 分析图示CMOS门**

(i) 这是一个什么门？ (3分)

这是一个 CMOS反相器 (Inverter)，也就是一个 非门 (NOT Gate)。

(ii) A和B哪个是p沟道MOSFET？ (2分)

A是p沟道MOSFET。在CMOS反相器结构中，p沟道MOSFET（PMOS）连接到高电压源（Vdd，此处为5V），n沟道MOSFET（NMOS）连接到地（GND，此处为0V）。

(iii) 简要解释这个门如何工作。(5分)

这个门的工作原理基于两个MOSFET互补的开关特性，由输入电压 Vin 控制。

- **当输入 Vin 为高电平 (High, 5V) 时:**
  - 对于上面的PMOS (A)，其栅极电压(5V)等于源极电压(5V)，VGS 为0V。这使得 **PMOS(A)关断**。
  - 对于下面的NMOS (B)，其栅极电压(5V)远高于源极电压(0V)，VGS 为+5V。这使得 **NMOS(B)导通**。
  - 由于A关断、B导通，输出端 Vout 通过导通的B被直接拉到地。所以 **Vout 为低电平 (Low, 0V)**。
- **当输入 Vin 为低电平 (Low, 0V) 时:**
  - 对于上面的PMOS (A)，其栅极电压(0V)远低于源极电压(5V)，VGS 为-5V。这使得 **PMOS(A)导通**。
  - 对于下面的NMOS (B)，其栅极电压(0V)等于源极电压(0V)，VGS 为0V。这使得 **NMOS(B)关断**。
  - 由于A导通、B关断，输出端 Vout 通过导通的A被直接连接到5V电源。所以 **Vout 为高电平 (High, 5V)**。

**总结**：输出状态总是与输入状态相反，实现了逻辑“非”的功能。

------

#### **(c) 给出CMOS逻辑门相对于TTL逻辑门的两个优点。(4分)**

与使用双极结型晶体管(BJT)构建的TTL（晶体管-晶体管逻辑）门相比，CMOS门有两个显著优点：

1. **极低的静态功耗 (Very Low Static Power Consumption)**：在稳定状态下（即输入为高电平或低电平时），CMOS反相器中的PMOS和NMOS总有一个是关断的。这意味着在电源和地之间没有直接的电流通路，因此几乎不消耗功率。功耗主要发生在输入状态切换的瞬间。而TTL门即使在稳定状态下也会持续消耗相当大的电流。
2. **更高的抗噪能力 (Higher Noise Immunity / Wider Noise Margins)**：CMOS门的输出电压可以实现“轨到轨”(rail-to-rail)摆动，即输出高电平非常接近电源电压Vdd，输出低电平非常接近地电压GND。其逻辑阈值电压通常在Vdd/2附近，这为高电平和低电平提供了很大的电压容限（噪声容限），使其不容易因电路中的噪声干扰而发生错误的逻辑翻转。TTL的电压摆幅较小，抗噪能力相对较弱。

------

------

### **English Summary (Key Points)**

#### **(a) n-channel MOSFET Sketch and Operation**

- **Structure Description**: Consists of a **p-type silicon substrate** with two **n-doped regions** (source and drain). A thin **oxide** layer insulates the **metal gate** from the channel region between the source and drain.

- Voltage-Controlled Switch

  :

  - **OFF State**: When Gate-Source voltage (VGS) is low (e.g., 0V), no conductive channel exists between source and drain; the switch is **open**.
  - **ON State**: When VGS is above the threshold voltage (Vth), an electric field forms an **n-type channel** under the gate, connecting the source and drain. Current can flow; the switch is **closed**.
  - The gate voltage controls the current path, making it a voltage-controlled switch.

#### **(b) CMOS Gate Analysis**

- **(i) Gate Type**: It is a **CMOS Inverter** (or **NOT gate**).

- **(ii) p-channel MOSFET**: Transistor **A** is the p-channel MOSFET (PMOS), as it is connected to the high voltage supply (5V).

- (iii) Function

  :

  - **Vin = HIGH (5V)**: PMOS (A) turns **OFF**, NMOS (B) turns **ON**. Vout is pulled down to **LOW (0V)**.
  - **Vin = LOW (0V)**: PMOS (A) turns **ON**, NMOS (B) turns **OFF**. Vout is pulled up to **HIGH (5V)**.
  - The output is always the logical inverse of the input.

#### **(c) Two Advantages of CMOS over TTL**

1. **Low Static Power Consumption**: In a steady state, one of the CMOS transistors is always off, preventing current flow from the power supply to ground. TTL gates continuously draw current.
2. **Higher Noise Immunity**: CMOS gates have a wider voltage swing (from ground to the supply rail) and a switching threshold typically near 50% of the supply voltage. This provides larger noise margins, making them less susceptible to electrical noise than TTL gates.