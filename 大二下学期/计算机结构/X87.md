# X87



## Gemini

### 前言

x87 浮点单元（FPU）是 Intel 8087 协处理器及其后续产品中的浮点运算核心。在现代 CPU 中，x87 指令集仍然被支持，尽管更现代的 SIMD 指令集（如 SSE、AVX）在性能上更优。学习 x87 对于理解底层浮点运算、维护旧代码或在特定嵌入式环境编程仍然有其价值。本教程将引导您逐步掌握 x87 汇编编程。

------

### 章节一：x87 FPU 入门

#### 1.1 什么是 x87 FPU？

x87 FPU 是一个专门用于执行浮点数学运算的处理器单元。早期，它是一个独立的协处理器芯片（如 8087），后来被集成到 CPU 内部。它有自己的一套寄存器和指令集。

#### 1.2 FPU 寄存器栈

x87 FPU 内部有8个80位浮点数据寄存器，组织成一个栈结构，名为 **ST(0) 到 ST(7)**。

- **ST(0)** (或简写为 **ST**) 始终指向栈顶。
- 数据加载（`FLD`）会将数据压入栈顶（原 ST(0) 变为 ST(1)，以此类推）。
- 数据存储并弹出（`FSTP`）会将 ST(0) 的值存到目标，并从栈中弹出该值（原 ST(1) 变为 ST(0)）。
- 大多数 FPU 指令对 ST(0) 或 ST(0) 与 ST(i) 进行操作。

#### 1.3 浮点数格式

x87 FPU 内部以 **80位扩展精度浮点格式** (temp real) 存储和处理数据，以减少中间计算的精度损失。当数据从内存加载或存储到内存时，可以转换为：

- **单精度 (Short Real / REAL4)**：32位，MASM 中用 `dd` 定义。
- **双精度 (Long Real / REAL8)**：64位，MASM 中用 `dq` 定义。
- **扩展精度 (Temp Real / REAL10)**：80位，MASM 中用 `dt` 定义。

------

### 章节二：核心概念

#### 2.1 FPU 控制字 (Control Word)

控制字是一个16位的寄存器，用于控制 FPU 的操作模式，例如：

- **精度控制 (PC)**：设置运算精度（24位、53位、64位）。
- **舍入控制 (RC)**：设置舍入模式（向最近偶数、向下、向上、向零）。
- **异常屏蔽 (EM)**：屏蔽或允许某些浮点异常（如除零、溢出）产生中断。

您提供的示例中 `cntrl dw 03FFh`：

- ```
  03FFh
  ```

   (二进制 

  ```
  0000 0011 1111 1111b
  ```

  )

  - PC (位 9-8): `11b` 表示 64位扩展精度。
  - RC (位 11-10): `00b` 表示向最近偶数舍入。
  - EM (位 5-0): `111111b` 表示所有异常都被屏蔽（不产生中断）。

常用指令：

- `FLDCW source`: 从内存加载控制字。
- `FSTCW destination`: 将控制字存储到内存（不等待）。
- `FNSTCW destination`: 将控制字存储到内存（等待）。

#### 2.2 FPU 状态字 (Status Word)

状态字是一个16位的寄存器，反映 FPU 的当前状态，例如：

- **忙碌位 (B)**：FPU 是否正在执行指令。
- **条件码 (C0-C3)**：用于比较和某些算术运算的结果。
- **栈顶指针 (TOP)**：指示 ST(0) 实际对应哪个物理寄存器。
- **异常标志 (ES, SF, PE, UE, OE, ZE, DE, IE)**：指示发生了哪些异常。

您提供的示例中 `FSTSW stat` 将状态字存入 `stat` 变量。
 `and al,0BFh` (二进制 `10111111b`) 是用来检查除了第6位（栈错误 SF）之外的其他5个异常标志位（PE, UE, OE, ZE, DE, IE）。

常用指令：

- `FSTSW destination`: 将状态字存储到内存或 AX 寄存器（不等待）。
- `FNSTSW destination`: 将状态字存储到内存或 AX 寄存器（等待）。
- `FCLEX`: 清除所有异常标志（不等待）。
- `FNCLEX`: 清除所有异常标志（等待）。

------

### 章节三：基本 x87 指令

#### 3.1 数据加载与存储

- **`FLD source`**: 加载实数到栈顶 ST(0)。

  - `FLD ST(i)`: 复制 ST(i) 的内容到 ST(0)。

  - ```
    FLD mem_real
    ```

    : 从内存加载单精度、双精度或扩展精度实数到 ST(0)。

    - 示例: `FLD SX` ; 将内存变量 SX (单精度) 加载到 ST(0)

- **`FST destination`**: 存储 ST(0) 的值到目标（不弹出栈）。

  - `FST ST(i)`: 将 ST(0) 的值复制到 ST(i)。
  - `FST mem_real`: 将 ST(0) 的值存储到内存（可能发生精度转换和舍入）。

- **`FSTP destination`**: 存储 ST(0) 的值到目标，并弹出栈顶。

  - `FSTP ST(i)`: 将 ST(0) 的值复制到 ST(i)，然后弹出 ST(0)。

  - ```
    FSTP mem_real
    ```

    : 将 ST(0) 的值存储到内存，然后弹出 ST(0)。

    - 示例: `FSTP HY` ; 将 ST(0) 的值存入 HY 并弹出

- **`FXCH ST(i)`**: 交换 ST(0) 和 ST(i) 的内容。

  - `FXCH` (无操作数) 等同于 `FXCH ST(1)`。

#### 3.2 常数加载

- `FLDZ`: 加载 +0.0 到 ST(0)。
- `FLD1`: 加载 +1.0 到 ST(0)。
- `FLDPI`: 加载 π 到 ST(0)。
- `FLDL2T`: 加载 log₂(10) 到 ST(0)。
- `FLDL2E`: 加载 log₂(e) 到 ST(0)。
- `FLDLG2`: 加载 log₁₀(2) 到 ST(0)。
- `FLDLN2`: 加载 ln(2) 到 ST(0)。

#### 3.3 基本算术运算

所有算术指令都有多种格式，可以操作寄存器或内存中的数据。

- **加法 (`FADD`)**

  - ```
    FADD ST(i), ST(0)
    ```

    : 

    ```
    ST(i) = ST(i) + ST(0)
    ```

    - 示例: `FADD ST(3), ST(0)` ; ST(3) = ST(3) + ST(0)

  - ```
    FADD ST(0), ST(i)
    ```

     (或 MASM 中 

    ```
    FADD ST, ST(i)
    ```

    ): 

    ```
    ST(0) = ST(0) + ST(i)
    ```

    - 示例: `FADD ST, ST(1)` ; ST(0) = ST(0) + ST(1) (您提供的示例中，结果在ST(0))

  - `FADD mem_real`: `ST(0) = ST(0) + mem_real`

  - ```
    FADD
    ```

     (无操作数): 

    ```
    ST(0) = ST(0) + ST(1)
    ```

    , 然后弹出 ST(1) (原ST(1)消失，原ST(0)中的结果成为新的ST(0))

    - 示例: `FADD` ; ST(0) = ST(0) + ST(1), pop. (您提供的示例描述正确)

  - `FADDP ST(i), ST(0)`: `ST(i) = ST(i) + ST(0)`, 然后弹出 ST(0)。

- **减法 (`FSUB`, `FSUBR`)**

  - ```
    FSUB
    ```

     (Subtract): 从目标中减去源。

    - `FSUB ST(0), ST(i)`: `ST(0) = ST(0) - ST(i)`
    - `FSUB ST(i), ST(0)`: `ST(i) = ST(i) - ST(0)`
    - `FSUB mem_real`: `ST(0) = ST(0) - mem_real`
    - `FSUB` (无操作数): `ST(0) = ST(0) - ST(1)`, pop.
    - `FSUBP ST(i), ST(0)`: `ST(i) = ST(i) - ST(0)`, pop.

  - ```
    FSUBR
    ```

     (Subtract Reversed): 从源中减去目标。

    - `FSUBR ST(0), ST(i)`: `ST(0) = ST(i) - ST(0)`
    - `FSUBR ST(i), ST(0)`: `ST(i) = ST(0) - ST(i)`
    - `FSUBR mem_real`: `ST(0) = mem_real - ST(0)`
    - `FSUBR` (无操作数): `ST(0) = ST(1) - ST(0)`, pop.
    - `FSUBRP ST(i), ST(0)`: `ST(i) = ST(0) - ST(i)`, pop.

- **乘法 (`FMUL`)**

  - `FMUL ST(i), ST(0)`: `ST(i) = ST(i) * ST(0)`

  - ```
    FMUL ST(0), ST(i)
    ```

     (或 MASM 中 

    ```
    FMUL ST, ST(i)
    ```

    ): 

    ```
    ST(0) = ST(0) * ST(i)
    ```

    - 示例: `FMUL ST, ST(0)` ; ST(0) = ST(0) * ST(0) (平方操作)

  - `FMUL mem_real`: `ST(0) = ST(0) * mem_real`

  - `FMUL` (无操作数): `ST(0) = ST(0) * ST(1)`, pop.

  - `FMULP ST(i), ST(0)`: `ST(i) = ST(i) * ST(0)`, pop.

  - `FIMUL mem_int`: 整数乘法，`ST(0) = ST(0) * mem_int`

- **除法 (`FDIV`, `FDIVR`)**

  - ```
    FDIV
    ```

     (Divide): 目标除以源。

    - `FDIV ST(0), ST(i)`: `ST(0) = ST(0) / ST(i)`
    - `FDIV ST(i), ST(0)`: `ST(i) = ST(i) / ST(0)`
    - `FDIV mem_real`: `ST(0) = ST(0) / mem_real`
    - `FDIV` (无操作数): `ST(0) = ST(0) / ST(1)`, pop.
    - `FDIVP ST(i), ST(0)`: `ST(i) = ST(i) / ST(0)`, pop.

  - ```
    FDIVR
    ```

     (Divide Reversed): 源除以目标。

    - `FDIVR ST(0), ST(i)`: `ST(0) = ST(i) / ST(0)`
    - `FDIVR ST(i), ST(0)`: `ST(i) = ST(0) / ST(i)`
    - `FDIVR mem_real`: `ST(0) = mem_real / ST(0)`
    - `FDIVR` (无操作数): `ST(0) = ST(1) / ST(0)`, pop.
    - `FDIVRP ST(i), ST(0)`: `ST(i) = ST(0) / ST(i)`, pop.

  - `FIDIV mem_int`: 整数除法, `ST(0) = ST(0) / mem_int`

#### 3.4 其他常用指令

- ```
  FSQRT
  ```

  : 计算 ST(0) 的平方根，结果仍在 ST(0)。

  - 示例: `FSQRT` ; ST(0) = sqrt(ST(0))

- `FABS`: 计算 ST(0) 的绝对值，结果仍在 ST(0)。

- `FCHS`: 改变 ST(0) 的符号，结果仍在 ST(0)。

- `FRNDINT`: 将 ST(0) 中的值舍入为整数（根据控制字的舍入模式）。

- `FXTRACT`: 分离 ST(0) 的指数和有效数（尾数）。指数存入 ST(0)，有效数压入栈成为新的 ST(0)。

#### 3.5 比较指令

比较指令会设置 FPU 状态字中的条件码 C0, C1, C2, C3。

- `FCOM source`: 比较 ST(0) 和 `source` (可以是 ST(i) 或内存实数)。
- `FCOMP source`: 比较 ST(0) 和 `source`，然后弹出 ST(0)。
- `FCOMPP`: 比较 ST(0) 和 ST(1)，然后弹出 ST(0) 和 ST(1) (弹出两次)。
- `FTST`: 比较 ST(0) 和 +0.0。
- `FXAM`: 检查 ST(0) 的类型（NaN, 无穷, 负数, 正数, 零等），并设置条件码。

比较结果与条件码的对应关系：

| ST(0) vs Source | C3   | C2   | C1   | C0   |
| --------------- | ---- | ---- | ---- | ---- |
| ST(0) > Source  | 0    | 0    | ?    | 0    |
| ST(0) < Source  | 0    | 0    | ?    | 1    |
| ST(0) = Source  | 1    | 0    | ?    | 0    |
| Unordered       | 1    | 1    | ?    | 1    |

要使用这些条件码进行条件跳转，通常需要：

1. `FSTSW AX` (或 `FNSTSW AX`): 将状态字存入 AX 寄存器。

2. ```
   SAHF
   ```

   : 将 AH (包含 C0, C2, C3) 复制到 CPU 的标志寄存器 (EFLAGS)。

   - C0 -> CF (Carry Flag)
   - C2 -> PF (Parity Flag)
   - C3 -> ZF (Zero Flag)

3. 使用条件跳转指令 (如 `JA`, `JBE`, `JE`, `JNE` 等)。

#### 3.6 FPU 控制指令

- ```
  FINIT
  ```

   / 

  ```
  FNINIT
  ```

  : 初始化 FPU 到默认状态（清除异常，设置默认控制字，清空栈）。

  ```
  FNINIT
  ```

   不会等待挂起的浮点异常。

  - 示例: `FINIT` ; 设置 FPU 到默认状态

- `FWAIT` (或 `WAIT`): 使 CPU 等待，直到 FPU 完成当前操作。这对于同步 CPU 和 FPU 操作很重要，尤其是在 FPU 操作后立即访问其结果或状态之前。

------

### 章节四：实战编程：计算 √(X² + Y²)

让我们详细分析您提供的代码，这是一个计算直角三角形斜边长度（勾股定理）的经典例子。

#### 4.1 MASM 程序结构

```assembly
.8087          ; 告诉 MASM 我们将使用 x87 FPU 指令
.MODEL SMALL   ; (可选，定义内存模型，这里假设是 .MODEL SMALL .STACK 100h)
.STACK 100h

.DATA
SX    dd 5.0     ; 定义单精度浮点数 X，值为 5.0
SY    dd 12.0    ; 定义单精度浮点数 Y，值为 12.0
HY    dd 0.0     ; 用于存储结果 HY (hypotenuse)
cntrl dw 03FFh   ; FPU 控制字: 扩展精度, 向最近偶数舍入, 屏蔽所有异常
stat  dw 0       ; 用于存储 FPU 状态字

.CODE
MAIN PROC
    .STARTUP          ; MASM 宏，处理程序入口点和 DS 初始化 (mov ax,@data; mov ds,ax)

    FINIT             ; 初始化 FPU，设置到默认状态
    FLDCW   cntrl     ; 加载我们定义的控制字到 FPU

    ; 计算 X*X
    FLD     SX        ; ST(0) = SX (5.0)
                      ; 栈: [5.0]
    FMUL    ST,ST(0)  ; ST(0) = ST(0) * ST(0) = 5.0 * 5.0 = 25.0
                      ; 栈: [25.0]

    ; 计算 Y*Y
    FLD     SY        ; ST(0) = SY (12.0), 原 ST(0) 变为 ST(1)
                      ; 栈: [12.0, 25.0]
    FMUL    ST,ST(0)  ; ST(0) = ST(0) * ST(0) = 12.0 * 12.0 = 144.0
                      ; 栈: [144.0, 25.0]

    ; 计算 X*X + Y*Y
    FADD    ST,ST(1)  ; ST(0) = ST(0) + ST(1) = 144.0 + 25.0 = 169.0
                      ; ST(1) 保持不变，但通常在此类序列后，我们认为ST(1)不再需要
                      ; 栈: [169.0, 25.0]
                      ; 注意：您提供的原始注释是 "FADD ST,ST(1) ; ADD top two numbers on stack"
                      ; 更准确的说法是 ST(0) = ST(0) + ST(1)。
                      ; 如果想实现 ST(0) = ST(0) + ST(1) 并弹出 ST(1)，可以使用 FADD (无操作数)
                      ; 假设当前栈顶是 Y*Y (ST(0))，次栈顶是 X*X (ST(1))
                      ; FADD  ; ST(0) = ST(0) + ST(1) = Y*Y + X*X, 然后弹出原 ST(1) (X*X)
                      ; 栈: [169.0]
                      ; 您的代码 FADD ST,ST(1) 结果是正确的，只是栈上还留着 ST(1) 的值。
                      ; 为了后续 FSQRT，这没有影响，因为它只操作 ST(0)。

    ; 计算 sqrt(X*X + Y*Y)
    FSQRT             ; ST(0) = sqrt(ST(0)) = sqrt(169.0) = 13.0
                      ; 栈: [13.0, 25.0] (如果之前是 FADD ST,ST(1))
                      ; 或 栈: [13.0] (如果之前是 FADD)

    ; 检查FPU状态 (可选，但良好实践)
    FNSTSW  stat      ; 将 FPU 状态字存储到 'stat' 变量 (FNSTSW 会等待 FPU 完成)
                      ; 使用 FSTSW 也可以，但通常前面加 FWAIT
    mov     ax, stat  ; 将状态字复制到 ax
    and     al, 0BFh  ; 检查低8位中的异常标志 (除了第6位栈故障SF)
                      ; 0BFh = 10111111b. 如果任何被检查的异常位置1, 结果非零
    jnz     pass      ; 如果有异常标志被设置，则跳转到 pass (错误处理)

    ; 存储结果
    FSTP    HY        ; 将 ST(0) 的值 (13.0) 存储到 HY，并从 FPU 栈中弹出
                      ; 栈: [25.0] (如果之前是 FADD ST,ST(1) 且未处理 ST(1))
                      ; 或 栈: [] (空) (如果之前是 FADD)

pass:
    nop               ; 标签，用于跳过存储或进行错误处理

    ; --- 程序结束前，通常需要清空FPU栈 ---
    ; 如果栈上还有残留数据 (例如上面例子中 ST(0) = 25.0)
    ; 可以使用 FSTP ST(0) 来丢弃，重复直到栈空
    ; FINIT 也会清空栈，但通常在程序结束时不这么做，除非要重置FPU
    ; 为了确保栈是干净的，可以根据之前操作数判断需要多少次 FSTP ST(0)
    ; 或者，如果知道栈上有N个元素，可以循环N次 FSTP ST(0)

    ; --- 打印 HY 的二进制表示 (如您示例所示) ---
    ; 这部分代码用于将 HY (一个32位浮点数) 的二进制位逐个打印出来
    ; 这对于调试和理解浮点数内部表示很有用，但不是打印其十进制值。
    ; 打印浮点数的十进制值在纯汇编中非常复杂，通常依赖C库或OS功能。

    ; 打印 HY 的高16位 (对于单精度浮点数，这是符号位、指数和部分尾数)
    mov     bx, OFFSET HY
    inc     bx
    inc     bx          ; BX 指向 HY+2 (高16位开始的地址)
    mov     ax, [bx]    ; AX = [HY+3][HY+2]
    mov     bx, ax      ; BX 现在包含 HY 的高16位
    ; (调用打印 BX 二进制的子程序)
    ; ... 您提供的打印代码 ...
    ; mov cx,16
    ; back_high: rol bx,1 ...

    ; 打印 HY 的低16位 (对于单精度浮点数，这是尾数的剩余部分)
    mov     bx, OFFSET HY ; BX 指向 HY+0 (低16位开始的地址)
    mov     ax, [bx]    ; AX = [HY+1][HY+0]
    mov     bx, ax      ; BX 现在包含 HY 的低16位
    ; (调用打印 BX 二进制的子程序)
    ; ... 您提供的打印代码 ...
    ; mov cx,16
    ; back_low: rol bx,1 ...

    .EXIT             ; MASM 宏，终止程序 (mov ah,4ch; int 21h)
MAIN ENDP

END MAIN
```

#### 4.2 代码解释与FPU栈变化追踪

假设 `SX = 5.0`, `SY = 12.0`.
 `cntrl = 03FFh` (扩展精度，向最近偶数舍入，屏蔽异常)。

1. ```
   FINIT
   ```

   - FPU 重置，栈空。

2. ```
   FLDCW cntrl
   ```

   - FPU 控制字设为 `03FFh`。

3. ```
   FLD SX
   ```

   - ST(0) = 5.0
   - FPU Stack: `[5.0]`

4. ```
   FMUL ST,ST(0)
   ```

    (即 

   ```
   FMUL ST(0), ST(0)
   ```

   )

   - ST(0) = ST(0) * ST(0) = 5.0 * 5.0 = 25.0
   - FPU Stack: `[25.0]`

5. ```
   FLD SY
   ```

   - 旧 ST(0) -> ST(1)，新值加载到 ST(0)。
   - ST(0) = 12.0, ST(1) = 25.0
   - FPU Stack: `[12.0, 25.0]`

6. ```
   FMUL ST,ST(0)
   ```

   - ST(0) = ST(0) * ST(0) = 12.0 * 12.0 = 144.0
   - FPU Stack: `[144.0, 25.0]`

7. ```
   FADD ST,ST(1)
   ```

    (即 

   ```
   FADD ST(0), ST(1)
   ```

   )

   - ST(0) = ST(0) + ST(1) = 144.0 + 25.0 = 169.0
   - FPU Stack: `[169.0, 25.0]` (ST(1) 仍然是 25.0)
   - *替代方案：如果使用 `FADD` (无操作数)，则 ST(0) = 169.0，并且原 ST(1) 被弹出。栈将是 `[169.0]`。这通常是更期望的行为，因为它清理了不再需要的操作数。*

8. ```
   FSQRT
   ```

   - ST(0) = sqrt(ST(0)) = sqrt(169.0) = 13.0
   - FPU Stack (基于 `FADD ST,ST(1)`): `[13.0, 25.0]`
   - FPU Stack (基于 `FADD`): `[13.0]`

9. ```
   FNSTSW stat
   ```

   - 将 FPU 状态字存入 `stat`。

10. ```
    mov ax,stat; and al,0BFh; jnz pass
    ```

    - 检查是否有异常（除栈故障外）。如果无异常，`al` 为0，不跳转。

11. ```
    FSTP HY
    ```

    - `HY` = ST(0) (13.0)。ST(0) 从栈中弹出。
    - FPU Stack (基于 `FADD ST,ST(1)`): `[25.0]` (栈顶现在是之前 X² 的结果，如果未使用 `FADDP` 或 `FADD` 无操作数形式)
    - FPU Stack (基于 `FADD`): `[]` (栈空)

#### 4.3 打印二进制值

您提供的打印代码段通过 `rol bx,1` 和检查进位 `jc` 来逐位打印 `bx` 寄存器中的16位值。这对于理解 IEEE 754 浮点数在内存中的确切位模式非常有用。

对于 `HY = 13.0` (单精度):

- 十进制 `13.0`
- 二进制 `1101.0`
- 规格化 `1.101 * 2^3`
- 符号位: 0 (正数)
- 指数: 3。偏置指数 (bias) 为 127。所以实际存储的指数 = 3 + 127 = 130。
  - 130 十进制 = `10000010` 二进制 (8位)
- 尾数 (Mantissa/Significand): `101` (去掉隐含的1之后的部分)，补齐到23位 -> `10100000000000000000000`
- 组合 (32位):
   `S EEEEEEEE MMMMMMMMMMMMMMMMMMMMMMM`
   `0 10000010 10100000000000000000000`
- 十六进制: `0x41500000`

所以，当您打印 `HY` 的二进制时：

- 高16位 (`[HY+3][HY+2]`): `0100000101010000` (对应 `0x4150`)
- 低16位 (`[HY+1][HY+0]`): `0000000000000000` (对应 `0x0000`)

这与您示例输出中的 `0100000101010000 0000000000000000` (如果HY=13.0) 是吻合的。
 您示例中的输出 `0100000101010000 0100000101000000` 可能是针对不同的值或存在小笔误，因为 `0x41400000` 对应的是 `12.0`。
 您的注释 `1.10100E3=1.101x2^3` 是正确的，`1101.000 = 13 decimal` 也是正确的。

------

### 章节五：进阶主题 (简要介绍)

#### 5.1 三角函数和超越函数

x87 FPU 提供了一些超越函数指令：

- `FSIN`: 计算 ST(0) 的正弦 (弧度)。
- `FCOS`: 计算 ST(0) 的余弦 (弧度)。
- `FSINCOS`: 同时计算 ST(0) 的正弦和余弦。余弦在 ST(0)，正弦压入栈顶。
- `FPTAN`: 计算 ST(0) 的正切 (弧度)。结果在 ST(0)，并将 1.0 压入栈顶。
- `FPATAN`: 计算 ST(1)/ST(0) 的反正切。结果在 ST(1) 并弹出 ST(0)。 ST(0) 必须为正。
- `FYL2X`: 计算 `ST(1) * log₂(ST(0))`。
- `FYL2XP1`: 计算 `ST(1) * log₂(ST(0) + 1.0)`。

这些指令通常有输入范围限制，超出范围可能导致不精确或异常。

#### 5.2 FPU 异常处理

当 FPU 发生错误（如除零、溢出、无效操作）时，会设置状态字中的相应异常标志。

- 如果控制字中对应的异常屏蔽位为1（屏蔽），FPU 会尝试按预定义方式处理异常（如返回 NaN 或无穷大），程序继续执行。
- 如果屏蔽位为0（不屏蔽），FPU 会产生一个硬件中断，操作系统或异常处理程序可以捕获并处理它。

#### 5.3 与高级语言的接口

在汇编中调用 C/C++ 函数或反之，涉及参数传递和返回值处理。

- 浮点参数通常通过 FPU 栈传递（例如，第一个浮点参数在 ST(0)）。
- 浮点返回值通常也在 ST(0) 中。
- 需要遵循特定调用约定（cdecl, stdcall 等）。

#### 5.4 FPU 栈管理

有效的 FPU 栈管理至关重要。确保在函数调用前后 FPU 栈是平衡的，避免栈溢出（加载超过8个值）或栈下溢（在空栈上执行弹出操作）。

- `FFREE ST(i)`: 标记 ST(i)为空闲，但不改变其内容或栈顶指针。
- `FINCSTP`: 增加栈顶指针 (相当于空弹出)。
- `FDECSTP`: 减少栈顶指针 (相当于空压入)。

------

### 章节六：总结与学习资源

本教程涵盖了 x87 FPU 编程的基础知识、核心概念、常用指令以及一个实战示例。要达到精通水平，需要大量实践和对细节的深入理解。

**关键点回顾：**

- FPU 使用寄存器栈 ST(0)-ST(7)。
- `FINIT` 初始化 FPU。
- `FLDCW` 设置操作模式，`FSTSW` 读取状态。
- `FLD` 加载数据，`FSTP` 存储并弹出。
- 算术指令 (`FADD`, `FSUB`, `FMUL`, `FDIV`) 有多种形式。
- `FWAIT` 用于同步 CPU 和 FPU。
- 注意栈管理和异常处理。

**进一步学习资源：**

1. **Intel® 64 and IA-32 Architectures Software Developer's Manuals**: 这是最权威的参考资料，特别是 Volume 1 (Basic Architecture) 和 Volume 2 (Instruction Set Reference)。
2. **Assembly Language Step-by-Step: Programming with Linux** by Jeff Duntemann (虽然是Linux，但x87部分通用)。
3. **Art of Assembly Language** by Randall Hyde (有在线版本)。
4. 各种大学课程材料和在线教程，搜索 "x87 FPU programming tutorial"。

通过不断练习编写和调试 x87 汇编代码，您将逐渐精通这项技术。祝您学习愉快！

## Deepseek

### 第一部分：x87浮点基础

### 1. x87浮点协处理器简介
x87是x86架构中的浮点运算单元，最初作为独立协处理器(如8087)出现，后来集成到CPU中。它使用基于栈的寄存器模型(8个80位寄存器ST(0)-ST(7))，支持多种浮点格式。

### 2. x87寄存器与栈结构
x87使用栈式结构，寄存器名为ST(0)到ST(7)，ST(0)通常为栈顶：
- 压栈操作使栈顶指针减小
- 弹栈操作使栈顶指针增大
- 寄存器是80位扩展精度格式

### 3. 基本数据类型
- 单精度(32位) float
- 双精度(64位) double
- 扩展双精度(80位) long double
- 整数(16/32/64位)

## 第二部分：x87指令集基础

### 1. 数据传送指令
```asm
FLD m32/m64/m80    ; 加载浮点数到ST(0)
FST m32/m64        ; 存储ST(0)到内存
FSTP m32/m64/m80   ; 存储ST(0)到内存并弹出
FILD m16/m32/m64   ; 加载整数到ST(0)
FIST m16/m32       ; 存储ST(0)为整数
FISTP m16/m32/m64  ; 存储ST(0)为整数并弹出
```

### 2. 算术运算指令
```asm
FADD                ; ST(1) = ST(1) + ST(0) 然后弹出
FADDP ST(i), ST     ; ST(i) = ST(i) + ST(0) 然后弹出
FSUB                ; ST(1) = ST(1) - ST(0) 然后弹出
FSUBP ST(i), ST     ; ST(i) = ST(i) - ST(0) 然后弹出
FMUL                ; 乘法
FDIV                ; 除法
FSQRT               ; 平方根
FABS                ; 绝对值
FCHS                ; 改变符号
```

### 3. 比较指令
```asm
FCOM                ; 比较ST(0)和ST(1)
FCOMP               ; 比较并弹出
FCOMPP              ; 比较并弹出两次
FTST                ; 比较ST(0)和0.0
```

### 第三部分：实用编程示例

#### 1. 简单浮点运算
```asm
section .data
    f1 dd 3.14
    f2 dd 2.71
    result dd 0

section .text
    fld dword [f1]     ; ST0 = 3.14
    fld dword [f2]     ; ST0 = 2.71, ST1 = 3.14
    faddp              ; ST0 = 3.14 + 2.71
    fstp dword [result]; 存储结果
```

#### 2. 混合整数浮点运算
```asm
section .data
    i_val dd 5
    f_val dd 0.0

section .text
    fild dword [i_val] ; 加载整数到浮点栈
    fsqrt              ; 计算平方根
    fstp dword [f_val] ; 存储结果
```

#### 3. 计算多项式值
```asm
; 计算 ax^3 + bx^2 + cx + d
section .data
    a dd 2.0
    b dd 3.0
    c dd 4.0
    d dd 5.0
    x dd 1.5
    result dd 0

section .text
    fld dword [x]      ; ST0 = x
    fld st0            ; ST0 = x, ST1 = x
    fmul dword [a]     ; ST0 = a*x
    fld st1            ; ST0 = x, ST1 = a*x, ST2 = x
    fmul st0, st0      ; ST0 = x^2
    fmul dword [b]     ; ST0 = b*x^2
    faddp st1, st0     ; ST0 = a*x + b*x^2
    fld dword [x]      ; ST0 = x, ST1 = a*x + b*x^2
    fmul dword [c]     ; ST0 = c*x
    faddp st1, st0     ; ST0 = a*x + b*x^2 + c*x
    fadd dword [d]     ; ST0 = a*x + b*x^2 + c*x + d
    fstp dword [result]
```

### 第四部分：高级主题

#### 1. 控制字与状态字
```asm
FSTCW [mem]      ; 存储控制字
FLDCW [mem]      ; 加载控制字
FSTSW [mem]      ; 存储状态字
FSTSW AX         ; 存储状态字到AX

; 控制字位域：
; 0-5: 异常掩码
; 8-9: 精度控制 (00=24位, 10=53位, 11=64位)
; 10-11: 舍入控制 (00=最近, 01=向下, 10=向上, 11=截断)
```

#### 2. 超越函数
```asm
FSIN            ; ST(0) = sin(ST(0))
FCOS            ; ST(0) = cos(ST(0))
FSINCOS         ; ST(0)=sin(x), 压入cos(x)
FPTAN           ; ST(0)=1.0, ST(1)=tan(x)
FPATAN          ; ST(0)=arctan(ST(1)/ST(0))
F2XM1           ; ST(0)=2^ST(0) - 1
FYL2X           ; ST(0)=ST(1)*log2(ST(0))
FYL2XP1         ; ST(0)=ST(1)*log2(ST(0)+1.0)
```

#### 3. 优化技巧
1. 尽量保持栈平衡，避免过多的FSTP/FCOMPP
2. 使用内存操作数减少寄存器压力
3. 合理安排计算顺序减少栈操作
4. 利用并行执行特性(FPU可以同时执行多条指令)

### 第五部分：现代x86中的x87

### 1. SSE替代x87
现代x86 CPU推荐使用SSE/SSE2指令集进行浮点运算：
- 更简单的编程模型(平面寄存器)
- 更好的性能
- 更一致的跨平台行为

### 2. 混合使用x87和SSE
```asm
; 示例：混合使用x87和SSE
movss xmm0, [f1]      ; SSE加载
cvtss2sd xmm0, xmm0   ; 转换为双精度
mulsd xmm0, [f2]      ; SSE乘法
cvtsd2ss xmm0, xmm0   ; 转换回单精度
movss [result], xmm0  ; 存储结果
```

### 3. x87的现代应用场景
1. 需要80位扩展精度的计算
2. 某些超越函数计算
3. 遗留代码维护
4. 某些特殊算法(如高精度数学库)

## 第六部分：调试与常见问题

### 1. 常见异常
- 无效操作(I)
- 除零(Z)
- 上溢(O)
- 下溢(U)
- 精度(P)

### 2. 调试技巧
1. 检查FPU状态字：
```asm
fstsw ax
sahf
; 然后检查标志位
```
2. 使用调试器检查FPU寄存器
3. 逐步执行检查栈变化

### 3. 性能考虑
1. x87指令通常有较长延迟
2. 避免频繁的栈操作
3. 注意指令配对和调度

## 附录：完整参考表

### x87指令速查表
| 类别     | 指令示例              | 描述            |
| -------- | --------------------- | --------------- |
| 数据传送 | FLD, FST, FSTP        | 加载/存储浮点数 |
|          | FILD, FIST, FISTP     | 加载/存储整数   |
| 算术运算 | FADD, FADDP           | 加法            |
|          | FSUB, FSUBP           | 减法            |
|          | FMUL, FMULP           | 乘法            |
|          | FDIV, FDIVP           | 除法            |
| 比较     | FCOM, FCOMP, FCOMPP   | 浮点比较        |
|          | FTST                  | 与0比较         |
| 超越函数 | FSIN, FCOS, FSINCOS   | 三角函数        |
|          | FPTAN, FPATAN         | 正切/反正切     |
|          | F2XM1, FYL2X, FYL2XP1 | 指数/对数函数   |
| 控制     | FLDCW, FSTCW          | 控制字操作      |
|          | FSTSW                 | 状态字操作      |
| 其他     | FINIT                 | 初始化FPU       |
|          | FWAIT                 | 等待FPU操作完成 |

希望这套教程能帮助你掌握x87浮点编程！从基础到高级应用，建议结合实际代码练习每个概念。

# 题目

根据您提供的x87浮点汇编知识范围，设计15道编程解答题：

## **基础难度（1-5题）**

### 编写程序计算两个单精度浮点数的和并存储结果。

 答案：

```assembly
.8087
.DATA
num1 dd 3.5
num2 dd 2.5
result dd 0.0

.CODE
FINIT              ; 初始化FPU
FLD num1           ; 加载3.5到ST(0)
FADD num2          ; ST(0) = ST(0) + num2 = 6.0
FSTP result        ; 存储结果并弹出栈
```

解析：这是最基本的浮点加法操作。FLD将第一个数加载到栈顶，FADD直接将内存中的第二个数与栈顶相加，结果保留在ST(0)。FSTP存储结果同时清空栈，保持栈平衡。

### 计算一个浮点数的平方。

 答案：

```assembly
.8087
.DATA
x dd 4.0
square dd 0.0

.CODE
FINIT              ; 初始化FPU
FLD x              ; 加载x到ST(0)
FMUL ST,ST(0)      ; ST(0) = ST(0) * ST(0) = 16.0
FSTP square        ; 存储结果
```

解析：FMUL ST,ST(0)是计算平方的标准方法，将栈顶元素与自身相乘。这比加载两次相同的值更高效。结果仍在ST(0)，体现了x87的就地运算特性。

### 实现浮点数减法：result = a - b。

 答案：

```assembly
.8087
.DATA
a dd 10.0
b dd 3.0
result dd 0.0

.CODE
FINIT              ; 初始化FPU
FLD a              ; ST(0) = 10.0
FSUB b             ; ST(0) = ST(0) - b = 7.0
FSTP result        ; 存储结果
```

解析：FSUB执行ST(0) = ST(0) - 内存操作数。注意操作数顺序：栈顶减去源操作数。如果需要反向减法（b-a），应使用FSUBR指令。

### 计算两个数的乘积并检查是否有异常。

 答案：

```assembly
.8087
.DATA
x dd 100.0
y dd 200.0
product dd 0.0
status dw 0

.CODE
FINIT              ; 初始化FPU
FLD x              ; 加载100.0
FMUL y             ; 乘以200.0
FSTSW status       ; 保存状态字
mov ax,status      ; 复制到AX
and al,3Fh         ; 检查低6位异常标志
jnz error_handler  ; 如果有异常则跳转
FSTP product       ; 无异常，存储结果
jmp done
error_handler:
    ; 异常处理代码
done:
```

解析：FSTSW保存FPU状态字，其中低6位是异常标志。3Fh(00111111b)检查所有6个异常位。这展示了基本的错误检查模式，确保计算结果有效。

### 使用无操作数FADD计算三个数的和。

 答案：

```assembly
.8087
.DATA
a dd 1.0
b dd 2.0
c dd 3.0
sum dd 0.0

.CODE
FINIT              ; 初始化FPU
FLD c              ; ST(0) = 3.0
FLD b              ; ST(0) = 2.0, ST(1) = 3.0
FLD a              ; ST(0) = 1.0, ST(1) = 2.0, ST(2) = 3.0
FADD               ; ST(0) = 1.0 + 2.0 = 3.0, 弹出一个
FADD               ; ST(0) = 3.0 + 3.0 = 6.0, 弹出一个
FSTP sum           ; 存储结果
```

解析：无操作数FADD将ST(0)和ST(1)相加，结果存入ST(0)，并弹出原ST(1)。这展示了栈操作的特性：后进先出。加载顺序与计算顺序相反是关键。

## **中级难度（6-10题）**

### 编写程序计算表达式：(a + b) * c - d。

 答案：

```assembly
.8087
.DATA
a dd 2.0
b dd 3.0
c dd 4.0
d dd 5.0
result dd 0.0

.CODE
FINIT              ; 初始化FPU
FLD a              ; ST(0) = 2.0
FADD b             ; ST(0) = 5.0
FMUL c             ; ST(0) = 20.0
FSUB d             ; ST(0) = 15.0
FSTP result        ; 存储结果
```

解析：这展示了如何按运算优先级组织指令序列。每个运算的结果保留在ST(0)供下一步使用。使用内存操作数形式避免了过多的栈操作，代码更清晰。

### 实现除法运算并处理可能的除零错误。

 答案：

```assembly
.8087
.DATA
dividend dd 10.0
divisor dd 0.0     ; 测试除零
quotient dd 0.0
status dw 0
cword dw 03FFh     ; 屏蔽所有中断

.CODE
FINIT              ; 初始化FPU
FLDCW cword        ; 加载控制字
FLD dividend       ; 加载被除数
FLD divisor        ; 加载除数
FTST               ; 测试ST(0)是否为0
FSTSW status       ; 获取状态
mov ax,status
sahf               ; 状态字到CPU标志
jz div_by_zero     ; 如果除数为0则跳转
FDIVR              ; ST(0) = ST(1)/ST(0)
FSTP quotient      ; 存储结果
FSTP ST(0)         ; 清理栈
jmp done
div_by_zero:
    FSTP ST(0)     ; 弹出除数
    FSTP ST(0)     ; 弹出被除数
    ; 设置错误标志或特殊值
done:
```

解析：在执行除法前先测试除数是否为零。FTST比较ST(0)与0.0，通过SAHF将FPU状态传递到CPU标志寄存器。FDIVR执行反向除法，因为除数在ST(0)。

### 计算平方根前先验证输入非负。

 答案：

```assembly
.8087
.DATA
x dd -4.0          ; 测试负数
root dd 0.0
error_flag db 0
status dw 0

.CODE
FINIT              ; 初始化FPU
FLD x              ; 加载x
FTST               ; 比较ST(0)与0
FSTSW status       ; 获取状态
mov ax,status
sahf               ; 传递到CPU标志
jb negative_input  ; 如果x < 0则跳转
FSQRT              ; 计算平方根
FSTP root          ; 存储结果
jmp done
negative_input:
    mov error_flag,1 ; 设置错误标志
    FSTP ST(0)       ; 清理栈
done:
```

解析：FSQRT对负数会产生无效操作异常。通过FTST预先检查可以避免异常。状态字的条件码通过SAHF传到CPU，允许使用标准条件跳转指令。

1. 实现完整的勾股定理计算：c = √(a² + b²)，包含错误检查。
    答案：

```assembly
.8087
.DATA
a dd 3.0
b dd 4.0
c dd 0.0
status dw 0
cword dw 03FFh

.CODE
FINIT              ; 初始化FPU
FLDCW cword        ; 设置控制字
FLD a              ; 加载a
FMUL ST,ST(0)      ; a²
FLD b              ; 加载b
FMUL ST,ST(0)      ; b²
FADD               ; a² + b²
FSQRT              ; √(a² + b²)
FSTSW status       ; 检查状态
mov ax,status
and al,0BFh        ; 检查异常（除栈错误外）
jnz error_occurred
FSTP c             ; 存储结果
jmp done
error_occurred:
    FSTP ST(0)     ; 清理栈
done:
```

解析：这是示例程序的简化版本。使用无操作数FADD减少了寄存器使用。0BFh屏蔽第6位（栈错误），检查其他所有异常。这种模式适合需要可靠性的计算。

1. 使用FSUBR实现表达式：result = c - (a * b)。
    答案：

```assembly
.8087
.DATA
a dd 2.0
b dd 3.0
c dd 10.0
result dd 0.0

.CODE
FINIT              ; 初始化FPU
FLD a              ; ST(0) = 2.0
FMUL b             ; ST(0) = 6.0
FLD c              ; ST(0) = 10.0, ST(1) = 6.0
FSUBR              ; ST(0) = ST(1) - ST(0) = 6.0 - 10.0 = -4.0
                   ; 错误！应该是 10.0 - 6.0
; 正确方法：
FINIT
FLD c              ; ST(0) = 10.0
FLD a              ; ST(0) = 2.0, ST(1) = 10.0
FMUL b             ; ST(0) = 6.0, ST(1) = 10.0
FSUBP              ; ST(0) = ST(1) - ST(0) = 10.0 - 6.0 = 4.0
FSTP result        ; 存储结果
```

解析：FSUBR执行反向减法容易混淆。使用FSUBP（带弹出）可以更清晰地控制操作数顺序。关键是理解：目标 - 源，以及栈操作的影响。

## **高级难度（11-15题）**

1. 实现浮点数的条件选择：if (x > y) result = x; else result = y;
    答案：

```assembly
.8087
.DATA
x dd 5.0
y dd 3.0
result dd 0.0
status dw 0

.CODE
FINIT              ; 初始化FPU
FLD y              ; ST(0) = y
FLD x              ; ST(0) = x, ST(1) = y
FCOM               ; 比较ST(0)与ST(1)
FSTSW status       ; 获取状态字
mov ax,status
sahf               ; 传递到CPU标志
ja keep_x          ; 如果x > y跳转
FXCH               ; 交换ST(0)和ST(1)
keep_x:
FSTP result        ; 存储较大值
FSTP ST(0)         ; 清理栈
```

解析：FCOM设置条件码但不改变栈。通过SAHF映射到CPU标志后，可以使用标准跳转。FXCH用于调整栈顺序，确保正确的值在栈顶。这展示了条件逻辑的实现。

### 计算数组元素的平方和。

答案：

```assembly
.8087
.DATA
array dd 1.0, 2.0, 3.0, 4.0, 5.0
count dw 5
sum dd 0.0

.CODE
FINIT              ; 初始化FPU
FLDZ               ; ST(0) = 0.0 (累加器)
mov si,0           ; 数组索引
mov cx,count       ; 循环计数
sum_loop:
    FLD array[si]  ; 加载数组元素
    FMUL ST,ST(0)  ; 平方
    FADD           ; 累加到总和
    add si,4       ; 下一个元素（4字节）
    loop sum_loop
FSTP sum           ; 存储结果
```

解析：FLDZ初始化累加器为0。循环中，每个元素被加载、平方，然后用无操作数FADD累加。SI寄存器按4字节递增访问单精度数组。这是典型的数组处理模式。

1. 实现安全的倒数计算：1/x，处理x=0和检查结果。
    答案：

```assembly
.8087
.DATA
x dd 2.0
reciprocal dd 0.0
infinity dd 7F800000h  ; IEEE 754正无穷
status dw 0
cword dw 03FFh

.CODE
FINIT              ; 初始化FPU
FLDCW cword        ; 设置控制字
FLD x              ; 加载x
FTST               ; 测试x是否为0
FSTSW status
mov ax,status
sahf
jz handle_zero     ; 如果x=0则特殊处理
FLD1               ; 加载1.0
FXCH               ; ST(0)=x, ST(1)=1.0
FDIV               ; ST(0) = ST(1)/ST(0) = 1/x
FSTSW status       ; 检查除法结果
mov ax,status
and al,0BFh
jnz error_handler
FSTP reciprocal    ; 存储结果
jmp done
handle_zero:
    FSTP ST(0)     ; 清理x
    FLD infinity   ; 加载无穷大
    FSTP reciprocal
    jmp done
error_handler:
    FSTP ST(0)     ; 清理栈
done:
```

解析：完整的错误处理包括预检查（避免除零）和后检查（捕获其他异常）。使用IEEE 754标准的无穷大表示处理特殊情况。FXCH确保操作数顺序正确。

1. 编写函数计算：f(x,y) = √(x²+y²)/(x+y)，完整错误处理。
    答案：

```assembly
.8087
.DATA
x dd 3.0
y dd 4.0
result dd 0.0
status dw 0
temp dd 0.0

.CODE
FINIT              ; 初始化FPU
; 先检查分母
FLD x              ; ST(0) = x
FADD y             ; ST(0) = x + y
FTST               ; 检查是否为0
FSTSW status
mov ax,status
sahf
jz denominator_zero
FST temp           ; 保存分母供后用

; 计算分子
FLD x              ; ST(0) = x
FMUL ST,ST(0)      ; ST(0) = x²
FLD y              ; ST(0) = y, ST(1) = x²
FMUL ST,ST(0)      ; ST(0) = y²
FADD               ; ST(0) = x² + y²
FTST               ; 检查是否为负（理论上不应该）
FSTSW status
mov ax,status
sahf
jb error_negative
FSQRT              ; ST(0) = √(x²+y²)

; 执行除法
FLD temp           ; ST(0) = x+y, ST(1) = √(x²+y²)
FDIVR              ; ST(0) = ST(1)/ST(0)
FSTSW status       ; 最终检查
mov ax,status
and al,0BFh
jnz final_error
FSTP result        ; 存储结果
jmp done

denominator_zero:
    FSTP ST(0)     ; 清理栈
    ; 处理分母为0
    jmp done
error_negative:
    FSTP ST(0)     ; 清理栈
    jmp done
final_error:
    FSTP ST(0)
done:
```

解析：复杂表达式需要分步计算和多重检查。保存中间结果（分母）避免重复计算。每个可能出错的步骤都有对应的错误处理。这展示了生产级代码的严谨性。

### **实现精确的舍入控制：将浮点数舍入到最近的整数。**

 答案：

```assembly
.8087
.DATA
x dd 3.7
rounded dd 0.0
old_cw dw 0
new_cw dw 0
status dw 0

.CODE
FINIT              ; 初始化FPU
; 保存当前控制字
FSTCW old_cw       ; 保存原控制字
mov ax,old_cw
mov new_cw,ax
; 设置舍入模式为最近偶数（默认）
and new_cw,0F3FFh  ; 清除RC位(bit 11-10)
or new_cw,0000h    ; RC=00（最近偶数）
FLDCW new_cw       ; 加载新控制字

FLD x              ; 加载3.7
FRNDINT            ; 舍入到整数
FSTSW status       ; 检查状态
mov ax,status
and al,0BFh
jnz error_round
FSTP rounded       ; 存储结果（4.0）

; 恢复原控制字
FLDCW old_cw
jmp done

error_round:
    FSTP ST(0)
    FLDCW old_cw   ; 确保恢复
done:
```

解析：FRNDINT使用控制字的RC位确定舍入方式。保存和恢复控制字是良好实践，避免影响后续运算。0F3FFh清除位11-10，然后可以设置不同的舍入模式：00=最近偶数，01=向下，10=向上，11=截断。

