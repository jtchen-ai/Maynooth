# Unix 消息队列与远程过程调用

* **远程过程调用 (Remote Procedure Call - RPC)**
    * **定义与目的**:
        * 一种比套接字更方便的通信抽象，构建在像套接字这样的底层连接机制之上。
        * 旨在通过允许像调用本地函数一样调用远程函数，来简化客户端/服务器编程。
        * 使用套接字字节流虽然灵活，但给程序员带来了编写代码来识别和调用函数、交换和解析参数及结果的负担。
        * 在像Java VM这样的面向对象环境中，这个机制被称为远程方法调用 (RMI - Remote Method Invocation)。

    * **工作原理**:
        * **通信存根 (Comms Stubs)**: RPC服务定义一个接口，从而可以自动生成通信存根。RPC机制的实现隐藏在存根代码中，这些存根随后与客户端和服务器代码静态链接。
        * **调用流程**:
            1. 客户端进程调用所需的过程并提供参数。
            2. 客户端RPC存根机制将参数打包成消息并发送给相应的服务器进程。
            3. 接收端存根解码消息，识别过程，提取参数，并在本地调用该过程。
            4. 结果被打包成消息并通过回复发送回去，由存根作为过程返回值传递给客户端。

    * **实现挑战**:
        * **服务器定位**:
            * RPC存根机制可能不知道特定服务在网络上的确切位置。
            * 服务器的套接字地址是通过首先与一个目录服务（如 `portmap` RPC名称服务器）通信来定位的，服务器已在该服务上注册。
        * **地址空间引用**:
            * 一些实现问题使得RPC机制难以做到完全透明。
            * 参数是通过值传递的，因为在远程地址空间中，指针引用无法被正确评估。这使得传递基于内存指针的数据结构或对象引用变得困难。
        * **数据格式转换 (Marshalling/Unmarshalling)**:
            * 如果服务器和客户端运行在不同的机器架构上或使用不同的编程语言编写，可能会出现困难。
            * RPC机制必须找到一种双方都同意的外部数据表示格式，以确保交换的信息被双方正确解释。
        * **失败语义 (Failure Semantics)**:
            * **至少一次 (At least once)**: 要求客户端存储请求以便重复传输。
            * **至多一次 (At Most Once)**: 要求请求和响应都标有序列号，并在客户端和服务器端保存以允许重传。
            * **恰好一次 (Exactly Once)**: 要求将请求和响应写入稳定存储，以在服务器崩溃时保留其效果。

* **Unix 消息队列 (Unix Message Queues)**
    * **定义与特性**:
        * 允许进程以异步方式交换**整个消息**形式的数据。
        * 不需要“会合”(rendezvous)。
        * 消息具有相关联的优先级，并按优先级顺序排队。

    * **消息队列管理器**:
        * 操作系统持久地、独立于用户进程地维护消息队列，直到它被用户进程显式地取消链接（销毁）或系统关闭。
        * 通信进程必须拥有对特定消息队列的访问权限。
        * 每个创建的消息队列由一个形式为 `"/somename"` 的名称字符串标识。

    * **与管道的比较**:
        * **管道**:
            * 无内部结构，只是字节流。
            * 无法区分不同写入者的内容。
            * 写入者没有优先级。
            * 无法确定管道内容的状态。
        * **消息队列**:
            * 内部结构和几何形状由用户设置。
            * 独立的消息是可区分的。
            * 队列按消息优先级排序。
            * 进程可以确定队列的状态和最大消息大小。

    * **API 函数**:
        * `mq_open()`: 创建一个新的消息队列或打开一个现有的队列。
        * `mq_send()`: 向队列写入一条消息。
        * `mq_receive()`: 从队列读取一条消息。
        * `mq_close()`: 关闭进程先前打开的消息队列。
        * `mq_unlink()`: 移除一个消息队列名称，并在所有进程都关闭它后标记该队列以便删除。

    * **内部结构与属性**:
        * 每个消息队列都有一组关联的属性，在创建时设置。
        * 可以使用 `mq_getattr()` 查询属性。
        * **`mq_attr` 结构**:
            * `mq_flags`: 标志 (0 或 O_NONBLOCK 语义)。
            * `mq_maxmsg`: 队列上的最大消息数。
            * `mq_msgsize`: 最大消息大小（字节）。
            * `mq_curmsgs`: 当前队列中的消息数。

    * **使用方法 (C语言)**:
        * **创建/打开**: 使用 `mq_open(qname, modeflags, permissions, &attr)`。
            * `modeflags` 可以是 `O_RDWR | O_CREAT`。
            * `permissions` 是一个模式掩码，如 `0600`。
        * **发送消息**: `mq_send(mq, buffer, max_size, priority)`。
        * **接收消息**: `numRead = mq_receive(mq, buffer, max_size, &priority)`。
        * **关闭与销毁**: `mq_close(mq)` 和 `mq_unlink(qname)`。
        * **编译**: 使用POSIX消息队列API的程序必须使用 `-lrt` 选项编译，以链接实时库 `librt`。

* **Unix 进程间通信机制总结**
    * **管道 (Pipes)**: 快速、基于内存、面向流，用于相关进程之间。
    * **命名管道 (Named Pipes)**: 类似管道，但使用共享文件，可用于不相关的进程。
    * **套接字 (Sockets)**: 低级别的互联网通信抽象，通常基于TCP/IP，用于不相关的进程之间。
    * **远程过程调用 (Remote Procedure Call)**: 简化客户端/服务器编程。
    * **消息队列 (Message Queues)**: 具有优先级排序的异步整条消息通信。