# 操作系统内存管理综合笔记

## 模块一：计算机体系结构基础

### 1. 冯・诺依曼结构 (Von Neumann Architecture)

冯・诺依曼结构是 1945 年由约翰・冯・诺依曼等人提出的存储程序计算机模型，至今仍是现代计算机操作的基础。

- **核心组件**:
  - 一个用于同时存放指令和数据的内存
  - 一个用于从内存中提取指令的控制单元
  - 一个用于执行指定操作的算术逻辑单元
  - 一个用于在内存和 CPU 之间传输数据的总线
  - 用于与系统内外传输数据的输入 / 输出机制和外围设备
- **关键瓶颈**:
  - 由于内存和 CPU 之间只有一条单一总线，指令提取和数据操作无法同时进行，这被称为 "冯・诺依曼瓶颈"

### 2. 哈佛结构 (Harvard Architecture)

哈佛结构提出了一种拥有独立指令和数据总线及内存系统的体系。

- 核心特点

  :

  - 允许指令的提取和数据的加载 / 存储并行独立地进行
  - 有两个独立的内存：程序内存和数据内存，通过两条独立的总线连接到 CPU

### 3. 改进型哈佛结构 (Modified Harvard Architecture)

现代通用计算机普遍采用改进型哈佛结构。

- 核心特点:
  - 数据和代码可以共同存储在统一的主内存中
  - CPU 内部使用分离的指令缓存（Inst Cache）和数据缓存（Data Cache）以获得更好的性能

## 模块二：内存管理基础

### 1. 内存层级 (Memory Hierarchy)

系统内存并非单一组件，而是一个由不同存储技术构成的层级结构，旨在平衡成本、容量和性能目标。

- **层级结构 (从快到慢)**:
  - CPU 寄存器 (CPU Registers)：速度最快，容量极小，直接被处理器访问，操作速度接近处理器时钟周期（纳秒级）
  - CPU 缓存 (CPU Cache)：L1, L2, L3 缓存，速度快，价格昂贵，容量小
  - 主内存 (Main Electrical Memory / RAM)：速度较快，价格和容量适中，访问时间为纳秒级
  - 固态存储 (Solid State Memory)：如 SSD，速度和价格适中
  - 机械与光学存储 (Magnetic and Optical Storage)：如硬盘，速度慢，价格便宜，容量大，访问时间为毫秒级
- **数据流**: 机械设备上的数据必须先由文件系统调入主内存，处理器才能直接访问
- **性能需求**: 内存系统向处理器提供指令的速度必须与处理器的执行速度相匹配，否则无法发挥处理器的全部性能

### 2. 内存管理器的角色

操作系统的内存管理器负责管理主内存和二级存储（交换空间）。CPU 缓存到主内存的映射由硬件控制，以保证性能。

- 核心职责:
  - **跟踪内存状态**：记录哪些内存部分正在使用，哪些是空闲的
  - **分配与回收**：在进程需要时为其分配内存，在进程结束后回收内存
  - **交换管理**：在虚拟内存系统中，当主内存不足以容纳所有进程时，负责管理主内存和磁盘之间的交换（Swapping）

### 3. 进程地址空间 (Process Address Space)

一个进程的地址空间可以被划分为三个主要区域。

- **文本区 (Text)**：存放程序代码，通常是静态的
- **栈区 (Stack)**：用于存放函数参数、局部变量和返回地址的栈帧。栈是一个后进先出（LIFO）的固定大小区域，分配和回收速度快。每个线程必须有自己的栈。
- **堆区 (Heap)**：用于动态创建数据结构和对象的可变大小区域。在堆上创建的变量在函数调用返回后仍然存在。堆空间的管理更复杂且耗时。

## 模块三：内存分配方案

### 1. 单道程序设计 (Monoprogramming)

最简单的内存管理方案，一次只运行一个程序，与操作系统共享内存。

- **内存布局**：操作系统可以位于 ROM 或 RAM 中，用户程序占用剩余部分
- **缺点**:
  - 设备利用率极低
  - 计算机资源在等待单个用户活动时大量闲置
  - 这种模型主要用于非常早期的计算机或专用的嵌入式系统

### 2. 多道程序设计 (Multiprogramming)

允许多个进程同时存在于内存中，给内存管理带来了新的挑战。

- 挑战:
  - **内存保护**：必须保护一个进程的内存空间不被其他进程（恶意的或有故障的）干扰
  - **动态重定位**：程序在编写和编译时不知道未来将被加载到内存的哪个位置。因此，程序中使用的相对地址必须在运行时映射到正确的物理地址

### 3. 固定分区 (Fixed Partitioning)

内存被划分为多个固定大小的区域（分区）。

- **硬件支持**：为了速度，地址转换和保护功能通常由硬件实现，例如使用基址寄存器（Base Register）和界限寄存器（Limit Register）
  - **基址寄存器**：存储进程所在分区的起始物理地址。硬件会自动将进程生成的每个逻辑地址加上基址寄存器的值，从而得到物理地址
  - **界限寄存器**：存储分区的大小或上界地址。硬件会检查进程生成的逻辑地址是否超过界限值，如果超过则产生地址空间异常，并由操作系统终止该进程
- **进程分配**:
  - 可以为每个不同大小的分区维护一个独立的进程队列
  - 也可以使用一个单一的进程队列，将进程加载到第一个足够大的可用分区中
- **问题**:
  - **内部碎片 (Internal Fragmentation)**：当一个较小的进程被分配到一个较大的分区时，分区内未被使用的空间就被浪费了，因为每个分区只能容纳一个进程
  - **外部碎片 (External Fragmentation)**：即使总的空闲物理内存足够，但由于没有一个足够大的连续分区来容纳新进程，导致该进程无法运行

### 4. 动态分区 (Dynamic Partitioning)

为了解决固定分区的问题，内存管理器可以根据每个进程的请求，从可用内存中动态地创建一个精确大小的分区。

- **特点**：分区的数量和大小是动态变化的，取决于当前系统中的进程
- **问题**:
  - **外部碎片 (External Fragmentation)**：随着进程的分配和释放，空闲内存区域会变得越来越小且不连续（碎片化）。这可能导致存在足够的总空闲空间，但没有一个连续的块来满足新的分配请求
- **解决方案**:
  - **内存紧缩 (Compaction)**：通过移动活动进程的地址空间，将分散的空闲区域合并成一个大的连续空闲区。这是一个非常耗时的操作，因为它涉及大量的内存读写

## 模块四：空闲空间管理技术

为了实现动态分区，内存管理器需要跟踪哪些内存部分是空闲的。主要有以下几种方法。

### 1. 位图 (Bitmaps)

将内存划分为小的固定大小的分配单元（如 1KB），并用一个位图来表示每个单元的状态（例如，1 表示已用，0 表示空闲）。

- **分配**：寻找位图中一串连续的 0，其长度足以满足请求
- **回收**：将被释放区域对应的位重置为 0
- **开销**：位图的大小取决于内存大小和分配单元的大小。例如，4GB 内存和 1KB 分配单元需要 512KB 的位图
- **权衡**:
  - **大分配单元**：位图较小，但可能导致更多的内部碎片（平均浪费半个分配单元）
  - **小分配单元**：内部碎片少，但位图会很大，搜索耗时

### 2. 链表 (Linked Lists)

维护一个记录了所有可变大小空闲块的位置和大小的链表。

- **分配**：搜索链表找到一个足够大的空闲块
- **回收**：将释放的块作为一个新节点添加到空闲链表中。回收时需要检查相邻块是否也是空闲的，如果是则合并成一个更大的空闲块
- **开销**：链表本身可以存储在空闲内存区域的起始部分
- **放置算法 (Placement Algorithms)**：决定如何从空闲链表中选择块的策略，目标是最小化紧缩需求
  - **首次适应 (First Fit)**：选择扫描到的第一个足够大的块
  - **下次适应 (Next Fit)**：从上次分配的位置开始进行首次适应搜索
  - **最佳适应 (Best Fit)**：选择能容纳进程的最小空闲块，但这会留下很小的、难以利用的碎片
  - **最差适应 (Worst Fit)**：选择最大的空闲块，切分后剩下的空闲块较大，可能更有用

### 3. 伙伴系统 (Buddy System)

这是一种折衷方案，允许动态大小的分区，但分区大小限制为 2 的幂，以简化分配和回收过程。

- 工作原理

  :

  - 系统为每种大小（2 的幂）的空闲块维护一个独立的链表
  - 当有内存请求时，系统会分配一个大小最接近且不小于请求的 2 的幂的块
  - 如果所需大小的块不存在，则分裂一个更大的块（其 "伙伴"）直到获得所需大小的块
  - 回收时，系统会检查被释放块的 "伙伴" 是否也空闲，如果是，则将它们合并成一个更大的块

## 模块五：分页式内存管理 (Paging)

分页是一种克服了分区方案限制的内存管理技术，但需要额外的硬件支持（内存管理单元 MMU）。

### 1. 核心思想

- 物理内存被划分为多个固定大小的单元，称为**页帧 (Page Frames)**
- 进程的逻辑地址空间也被划分为同样大小的单元，称为**页 (Pages)**
- 进程的物理页面可以从内存中任何可用的页帧中分配，它们**不需要是连续的**

### 2. 地址转换

- CPU 生成的是**逻辑地址**，由**页号**和**页内偏移**组成
- **页表 (Page Table)**：每个进程都有一个页表，用于存储其逻辑页到物理页帧的映射关系
- **MMU (Memory Management Unit)**：硬件单元，负责查询页表，将逻辑地址中的页号替换为对应的物理页帧号，然后与页内偏移组合成最终的**物理地址**

### 3. 优点

- **保护**：进程只能访问其页表中映射的页面，无法访问其他进程的地址空间
- **灵活性**：分配给进程的物理页面可以分散在物理内存各处
- **易于管理**：跟踪和分配空闲空间变得简单。可以轻松地通过修改页表来重定位或扩展进程的地址空间

### 4. 缺点

- **页表开销**：页表本身可能很大，需要存储在主存中，造成额外开销
- **性能开销**：每次逻辑内存访问可能需要两次物理内存访问（一次访问页表，一次访问数据），除非部分页表被缓存（如使用 TLB）。页映射过程会轻微减慢内存访问速度
- **内部碎片**：由于内存按页分配，进程最后一个页面通常不会被完全使用，平均每个进程会浪费半个页面的空间

## 模块六：虚拟内存 (Virtual Memory)

虚拟内存允许进程的逻辑地址空间可以远大于实际的物理内存容量。

### 1. 请求分页 (Demand Paging)

- **核心思想**：根据程序的**局部性原理**（一个进程在任何时期都只会访问其一小部分地址空间），只将进程当前需要的页面（工作集）加载到物理内存中
- **实现**:
  - 在硬盘上使用一个**交换文件 (swap file)** 来存储每个活动进程的完整逻辑地址空间
  - 内存管理器只将部分页面从交换文件加载到物理内存中
- **优点**:
  - 提高了多道程序设计的程度，因为每个进程占用的物理内存更少
  - 允许运行比物理内存更大的程序

### 2. 页错误 (Page Fault)

- **页表修改**：页表项中增加一个**有效 / 无效位 (valid/invalid bit)**。`valid`表示页面在物理内存中，`invalid`表示不在。
- **处理流程**:
  1. 当 CPU 访问一个被标记为`invalid`的页面时，MMU 会触发一个**页错误 (page fault)** 陷阱
  2. 操作系统接管控制权
  3. 操作系统在交换文件中找到所需的页面
  4. 将其加载到一个空闲的物理页帧中。如果没有空闲页帧，则需要运行页面置换算法
  5. 更新进程的页表，将对应页表项标记为`valid`
  6. 重新执行导致错误的指令

### 3. 工作集 (Working Set)

分配给一个进程的物理页帧集合被称为其**工作集**。工作集的大小会影响系统性能。如果工作集太小，进程会频繁地发生页错误，导致页面在内存和磁盘之间不断交换，这种现象称为**系统颠簸 (Thrashing)**。

### 4. 页面置换算法 (Page Replacement Algorithms)

当需要加载一个新页面但没有空闲物理页帧时，必须选择一个当前在内存中的页面换出到磁盘。选择哪个页面由页面置换算法决定。

- **最佳算法 (Optimal, OPT)**：替换最长时间内不会被使用的页面。这是理论上最优的算法，无法在实际中实现，但可以作为衡量其他算法性能的基准
- **先进先出 (First-In, First-Out, FIFO)**：替换在内存中停留时间最长的页面。实现简单，但其行为与程序的局部性原理不太匹配
- **最近最少使用 (Least Recently Used, LRU)**：替换最长时间未被访问的页面。基于 "如果一个页面最近被访问，那么它很可能在不久的将来再次被访问" 的启发式思想。性能接近最优算法，但实现需要硬件支持（如为每页维护一个时间戳或计数器）
- **最不经常使用 (Least Frequently Used, LFU)**：替换在过去一段时间内被访问次数最少的页面。当进程改变其引用局部性时，新进入的页面由于访问频率低可能被错误地换出

### 5. Belady 异常 (Belady's Anomaly)

一个反直觉的现象：对于某些页面置换算法（如 FIFO），为进程分配更多的物理页帧有时反而会导致页错误率上升