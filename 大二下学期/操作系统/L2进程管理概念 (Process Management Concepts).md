# L2进程管理概念 (Process Management Concepts)

* **1. 程序、进程与处理器 (Programs, Processes, Processors)**
    * **程序 (Program)**
        * 定义: 程序是指定了明确执行顺序的指令集合。
        * 本质: 算法到编程语言的转换。
        * 编译: 编译器将程序代码映射为特定处理器的机器指令，并存储在目标文件中。
        * 链接: 多个编译后的目标文件可以被链接器（Linker）组合成一个可执行文件（Executable file）。
    * **进程 (Process)**
        * 定义: 进程是程序在执行中的一个实例。它是一个操作系统的抽象概念。
        * 执行: 当指令被执行时，进程就存在了。
        * 程序映像 (Program Image): 程序的可执行模块被加载到主内存中成为程序映像，处理器从中获取指令。
            * 程序映像的格式特定于某个操作系统和处理器，包含程序参数、堆栈空间、数据空间和程序代码。
        * 执行上下文: 进程是一个执行上下文，是内核管理的一系列在运行时所需的信息。
        * 特性:
            * 进程是动态实体，生命周期从几毫秒到数月不等。
            * 进程可以是持久的，用于实现系统服务。
            * 操作系统本身也由多个进程组成（如进程管理器、内存管理器等）。
    * **处理器 (Processor / CPU)**
        * 定义: 处理器是通过执行存储在内存映像中的指令来运行进程的代理。
        * 单处理器: 大多数桌面电脑只有一个处理器（CPU）。
        * 多核处理器: 现代处理器拥有多个执行“核心”，能够同时执行多个进程的指令。
    * **进程状态**
        * 就绪进程 (Ready Processes): 由于进程数量远多于处理器数量，系统通过分时共享让就绪的进程轮流使用CPU。
        * 阻塞进程 (Blocked Processes): 进程并不总是准备好使用处理器，有时它们必须等待其他设备（如等待数据供应）、等待需要分配或已被占用的资源，或者等待用户交互或计时周期。

* **2. 进程抽象的表示 (Representing Process Abstractions)**
    * **进程管理 (Process Management)**
        * 是操作系统的基本任务，包括创建、控制、终止进程以及管理执行环境。
        * 操作系统必须为进程分配资源（如内存、CPU时间），保护资源不受其他进程影响，并提供共享资源的进程间的同步机制。
    * **进程控制块 (Process Control Block - PCB)**
        * 定义: 也称为进程描述符（process descriptor），是操作系统为每个进程维护的数据结构，用于记录进程的状态、执行点和已分配的资源。
        * 目的: PCB用于跟踪进程的执行上下文，以便独立地将该进程调度到任何可用的处理器上。
        * **PCB包含的信息**:
            * **进程标识数据 (Process Identification Data)**
                * 唯一的进程标识符
                * 所有者的用户标识符
                * 组标识符
            * **处理器状态数据 (Processor State Data)**
                * CPU寄存器状态
                * 指向堆栈和内存空间的指针
                * 优先级
                * 调度参数
                * 等待的事件
            * **进程控制数据 (Process Control Data)**
                * 标志、信号和消息
                * 指向同一队列中其他进程的指针
                * 父子进程链接指针
                * 对I/O对象的访问权限
                * 记账信息

* **3. 进程生命周期 (Process Lifecycle)**
    * **进程队列 (Process Queues)**
        * 在进程的生命周期中，其PCB会根据优先级或执行状态在不同的队列之间移动。
        * 队列中保存着等待不同资源的进程，这些资源通过调度算法进行服务。
        * 进程的PCB代表该进程存在于操作系统的某个队列上。
    * **进程状态转换图 (Process State Transition Diagram)**
        * 进程在其生命周期中，会在需要CPU执行指令的时期和等待其他系统资源（如I/O设备）的时期之间切换。
        * **状态**:
            * **READY (就绪)**: 进程被创建后进入此状态。
            * **CPU (Running/运行)**: 由调度程序（Dispatch）从READY状态选择一个进程来执行。
            * **WAITING (等待/阻塞)**: 进程发出I/O请求后，从运行状态进入等待状态。
            * **ZOMBIE (僵尸)**: 进程正常或异常终止后进入的状态。
        * **转换**:
            * `READY -> CPU`: 调度 (Dispatch)
            * `CPU -> READY`: 抢占 / 时间片用完 (Preempt / Quantum Expired)
            * `CPU -> WAITING`: 发出等待I/O请求 (Wait I/O Request)
            * `WAITING -> READY`: 事件/I/O完成 (Event I/O Complete)
            * `CPU -> ZOMBIE`: 正常或异常终止 (Normal or abnormal termination)

* **4. 与操作系统通信 (Communicating with the OS)**
    * **通信机制**
        * 出于安全和可靠性考虑，不相关的进程之间或进程与硬件/操作系统之间的直接通信必须通过特定机制完成。
        * **进程间通信 (Interprocess Communication)**: 通过操作系统提供的IPC功能进行调节，这些功能将消息数据从一个进程映射到另一个进程。
        * **与操作系统通信**: 通过特殊的**系统调用（System Call）**机制完成，该机制会自动切换处理器的执行模式。
    * **处理器执行模式 (Processor Modes of Execution)**
        * **用户模式 (User Mode)** 和 **超级用户模式 (Supervisor Mode)**。
        * 为保护硬件，某些处理器指令是受限制的，不能被普通用户进程执行。
        * 执行用户进程时，处理器处于用户模式，只能执行其指令集的子集。
        * 执行操作系统代码时，处理器必须受控地切换到超级用户模式，才能执行其完整的指令集。
    * **系统调用 (System Calls)**
        * **切换模式**: 通过一种称为**软件中断 (software interrupt)** 的特殊处理器指令来实现向超级用户模式的切换。
        * **目的**: 进程需要通过系统调用来获取受保护的系统服务，如访问硬盘、创建新进程、进行IPC等。
        * **访问方式**: 系统调用通常通过与用户空间进程链接的**包装库 (wrapper libraries)** 来访问。
            * 包装函数检查参数的正确性并调用软件中断机制。
            * 包装API有助于应用程序代码在不同内核和语言实现之间的可移植性。
    * **硬件与操作系统通信**
        * **硬件中断 (Hardware Interrupts)**: 通过硬件中断机制实现。
            * 硬件设备发送电信号，以表明它们需要关注或已完成任务。
            * 这是管理大量硬件设备的有效方式，轮询设备状态效率低下。
        * **实现多任务环境 (Multitasking)**: 硬件中断机制对实现多任务环境至关重要。
            * 当一个任务被调度使用处理器固定时间时，会初始化一个时钟计时器。
            * 当时间用尽，中断信号会调用操作系统调度程序来选择另一个进程。
            * 该机制防止一个进程无限期地占用CPU。