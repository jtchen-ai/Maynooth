# 进程调度 I (Process Scheduling I)

* **多任务概念 (Multitasking Concepts)**
    * **多任务 (Multitasking)**: 一种允许多个进程同时驻留在计算机系统中并处于活动状态的操作系统特性。
    * **多用户多任务 (Multiuser Multitasking)**: 在这种系统中，一些进程可能属于不同的用户。

* **进程调度 (Process Scheduling)**
    * **基本问题**:
        * 多任务系统中的进程数量通常远大于处理器数量。
        * 每个进程必须与其他进程竞争可用的资源。
        * CPU时间是宝贵的，操作系统必须决定将哪个进程分配给处理器使用以及使用多长时间。
    * **OS控制与调度决策 (OS Control & Scheduling Decision)**
        * **触发**: 当一个进程进行系统调用或其在处理器上的时间片用完时，产生的软件或硬件中断会使CPU停止当前进程的指令获取，并切换到内核中指定的代码来处理中断。
        * **决策**: 此时，操作系统可能会决定将CPU分配给另一个进程。
    * **上下文切换 (Context Switch)**
        * **过程**:
            * 操作系统保存当前进程的运行时状态到其进程控制块（PCB）中，以便稍后可以继续执行。
            * 然后执行调度程序代码，加载所选新进程的运行时状态，以便CPU继续执行该新进程。
        * **特性**:
            * 上下文切换代码必须是高效的。
            * 通常由硬件指令支持。
            * 会产生性能开销，因为CPU正在花费时间执行操作系统代码。

* **多处理概念 (Multiprocessing Concepts)**
    * **定义**: 在一个系统中使用多个CPU。这通常指独立的物理CPU，但该概念也适用于具有多个执行核心的单个CPU。
    * **非对称多处理 (Asymmetric Multiprocessing)**
        * **工作方式**: 一个处理器（主处理器）集中执行操作系统代码，处理I/O操作，并将工作负载分配给其他执行用户进程的处理器。
        * **优点**: 只有一个处理器访问用于资源控制的系统数据结构，这使得操作系统功能的编码更容易。
        * **缺点**: 在处理器较少的小型系统中，主处理器可能没有足够的从处理器来保持其繁忙，因此无法实现最大的硬件性能。
    * **对称多处理 (Symmetric Multiprocessing - SMP)**
        * **工作方式**: 所有处理器执行相似的功能并且是自调度的。
        * **架构**: 相同的处理器使用共享总线连接到单个共享主内存，并可以完全访问所有I/O设备，由单个操作系统实例控制。
        * **挑战**: 每个处理器在选择要执行的进程时，会与其他处理器同时检查和操作操作系统队列结构。这种访问冲突必须小心编程，以保护共享数据结构的完整性。

* **调度算法性能 (Scheduling Algorithm Performance)**
    * **关注点**: 本节主要关注等待分配给处理器的进程队列，即“就绪队列”。
    * **性能评估标准 (Evaluation Criteria)**
        * **处理器利用率 (Processor Utilisation)** = 执行时间 / 总时间
        * **吞吐量 (Throughput)** = 单位时间完成的作业数
        * **周转时间 (Turnaround Time)** = 作业完成时间 - 作业提交时间
        * **等待时间 (Waiting Time)** = 在队列中什么都不做的时间
        * **响应时间 (Response Time)** = 作业首次在CPU上调度的时间 - 作业提交时间
    * **甘特图 (Gantt Chart)**
        * 用于描述调度顺序。
        * 表示每个进程按描述的顺序在特定资源上获得的时间单位数量。
    * **调度类型 (Scheduling Types)**
        * 调度算法可以是**抢占式 (preemptive)** 或 **非抢占式 (non-preemptive)**。
        * 所有多任务系统都会采用抢占式调度，否则一个进程可能永远不会放弃对CPU的控制。

* **非抢占式算法分析 (Analysis of Non-preemptive Algorithms)**
    * **分析方法**: 使用确定性建模，即定义一个工作负载模式，并比较不同算法的结果。
    * **示例工作负载**
        * Job 1: CPU Burst Time = 24
        * Job 2: CPU Burst Time = 3
        * Job 3: CPU Burst Time = 3
    * **先来先服务 (FCFS - First Come First Served)**
        * **调度顺序**: P1 -> P2 -> P3
        * **性能结果**
            * 平均等待时间: 17
            * 平均响应时间: 17
            * 平均周转时间: 27
        * **分析**: FCFS是一种本质上公平的算法，但对于响应时间很重要的交互式系统以及作业长度差异很大的情况，其性能很差。
    * **最短作业优先 (SJF - Shortest Job First)**
        * **假设**: 为学术目的，假设在调度决策前预先知道CPU突发时间（Burst Time）。
        * **调度顺序**: P2 -> P3 -> P1
        * **性能结果**
            * 平均等待时间: 3
            * 平均响应时间: 3
            * 平均周转时间: 13
        * **分析**:
            * 在吞吐量、等待时间和响应性能方面，SJF被证明是最佳算法，但它不公平。
            * SJF偏爱短作业。
            * 短作业的到来会无限期地推迟长作业的调度，即使长作业已经在就绪队列中等待了很长时间。
            * 这被称为**饥饿 (starvation)**。
        * **估算CPU突发长度**:
            * 在实践中，无法预知CPU突发长度，但可以用平滑公式根据其历史性能进行估算。
            * 公式: $t_{n+1} = at_n + (1-a)T_n$，其中 $0 \le a \le 1$。
    * **最高响应比优先 (HRN - Highest Response Ratio Next)**
        * **目标**: 解决SJF中长作业饥饿问题，使作业在系统中等待CPU的时间越长，被调度的机会就越大。
        * **类型**: 基于优先级的算法。
        * **响应比计算**: 响应比 = 等待时间 / 服务时间
        * **效果**: 当作业在就绪队列中等待时，其优先级会增加。