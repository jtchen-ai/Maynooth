### 第二部分：进程互斥问题

这份复习资料根据您提供的 PDF 内容整理而成，涵盖了所有核心知识点，并以中英双语对照形式呈现。

#### **1. 互斥问题 (The Mutual Exclusion Problem)**

- **背景 (Background):**

  - 线程是一种为程序添加并发的简单机制，但需要对线程活动进行协调，特别是协调对共享资源的访问。 
  - Threads are a simple mechanism for concurrency, but they require coordination, especially for accessing shared resources. 

- **问题定义 (Problem Definition):**

  - 在一个协作系统中，多个线程可能需要共享一段代码。 

  - In a cooperative system, multiple threads may need to share a segment of code. 

  - 这段共享代码被称为“临界区”（Critical Section）。 

  - This shared code is known as the "Critical Section". 

  - 互斥要求：

     任何时候都不能有两个或以上的线程同时执行这个临界区。 

  - 

    Mutual Exclusion Requirement:

     No two threads must be able to execute this critical section at the same time. 

#### **2. 解决方案探索：火车司机问题类比 (Exploring Solutions: The Train Drivers Problem Analogy)**

- 场景 (The Scenario):
  - 用一个类比来理解互斥问题：两列火车（代表线程）共享一段单轨“山口”（代表临界区）。 
  - An analogy is used to understand the problem: two trains (threads) share a single-track "Mountain Pass" (critical section). 
  - 关键约束是司机们既盲又聋，需要一种机制来防止碰撞（违反互斥）。 
  - The key constraint is that the drivers are blind and deaf and need a mechanism to prevent collisions (violating mutual exclusion). 

------

#### **3. 四种方法的尝试与分析 (Analysis of Four Attempted Methods)**

- **方法一：一个碗，初始为空 (Method 1: One Bowl, Initially Empty)**

  - 流程 (Procedure):

     进入前，检查碗是否为空。 

    如果是，放入一块石头然后进入。 

    如果碗里有石头，就重复等待直到碗变空。 

    离开后，取走石头。 

  - 软件等价物 (Software Equivalent):

     使用一个共享标志 

    ```
    flag
    ```

     (初始为0)。

    ```
    while(flag==1); flag=1; /*临界区*/; flag=0;
    ```

    。 

  - 缺陷 (Flaws):

    1. 饥饿 (Starvation):

        不公平的调度可能导致一个线程永远等待，无法进入临界区。 

    2. 违反互斥 (Mutual Exclusion Violation):

        两个线程可能在几乎同一时间都检查到碗是空的（

       ```
       flag
       ```

       为0），然后在对方放入石头（设置

       ```
       flag
       ```

       为1）之前，都决定进入临界区，导致碰撞。这是一种“竞争条件”(Race Condition)。 

- **方法二：严格轮流 (Method 2: Strict Alternation)**

  - 流程 (Procedure):

     一个司机必须等碗空了才能进，另一个必须等碗里有石头才能进，强制轮流。 

  - 软件等价物 (Software Equivalent):

     使用一个共享变量 

    ```
    turn
    ```

     来决定轮到谁。

    ```
    while(turn != my_turn); /*临界区*/; turn = other_turn;
    ```

    。 

  - 缺陷 (Flaw):

    1. 性能低下/活性问题 (Poor Performance/Liveness):

        该方法强制执行“锁步”（lock step）的严格交替。如果一个线程需要比另一个线程更频繁地进入临界区，这将导致效率低下。 

- **方法三：两个碗 (Method 3: Two Bowls)**

  - 

    流程 (Procedure):

     每个司机在进入前，先在

    自己的碗里放石头表示“意图”，然后检查对方的碗。 

    如果对方的碗是空的，自己就进入。如果不是，就等待。 

  - 软件等价物 (Software Equivalent):

     使用一个布尔数组 

    ```
    flag[2]
    ```

    。线程 

    ```
    i
    ```

     的逻辑是: 

    ```
    flag[i] = true; while(flag[j]); /*临界区*/; flag[i] = false;
    ```

    。 

  - 缺陷 (Flaw):

    1. 死锁 (Deadlock):

        两个线程可能同时在自己的碗里放了石头（设置自己的

       ```
       flag
       ```

       为

       ```
       true
       ```

       ），然后它们都会去检查对方的碗，发现对方也有意图，于是双方都陷入了无限等待对方放弃的状态，谁也无法前进。 

- **方法四：一个碗，初始为满 (Method 4: One Bowl, Initially Full)**

  - 

    流程 (Procedure):

     碗里初始就有一块石头。 

    任何想进入的司机必须

    先取走

    石头，然后进入。 

    离开后，再把石头

    放回

    碗里。 

    如果发现碗是空的，就等待。 

  - 软件等价物 (Software Equivalent):

    ```
    int flag = 1; while(flag==0); flag=0; /*临界区*/; flag=1;
    ```

    。 

  - 缺陷 (Flaw):

    1. 在软件中同样会违反互斥。

        

------

#### **4. 核心结论：原子性的重要性 (Core Conclusion: The Importance of Atomicity)**

- 物理世界与软件世界的差异 (Difference Between Physical and Software Worlds):

  - 方法4在火车司机的类比中是成功的，但在软件中失败了。 

  - 原因是，物理上“检查并取走石头”这个动作是

    不可分割的 (indivisible)

     或 

    原子的 (atomic)

    。一次只能有一个司机完成这个组合操作。 

  - The reason is that the physical action of "finding AND taking the rock" is indivisible or atomic

    .  Only one driver can perform this combined action at a time.

- 软件中的问题 (The Problem in Software):

  - 在软件中，

    ```
    while(flag==0){}
    ```

     (检查) 和 

    ```
    flag=0
    ```

     (设置/取走) 是两个独立的、可被中断的指令。 

  - In software, 

    ```
    while(flag==0){}
    ```

     (testing) and 

    ```
    flag=0
    ```

     (setting/taking) are two separate, interruptible instructions. 

  - 操作系统可能会在这两个指令之间切换线程，导致一个线程检查完 

    ```
    flag
    ```

     但还未设置 

    ```
    flag
    ```

     时，另一个线程也被调度进来执行了检查，从而两个线程都进入了临界区。 

  - An operating system might switch threads between these two instructions, allowing one thread to test the flag but before it can set it, another thread is scheduled and also tests the flag, leading both to enter the critical section. 

- 最终解决方案的要求 (Requirement for a Final Solution):

  - 要真正解决互斥问题，检查和设置共享变量（例如，测试锁并获取锁）的操作

    必须是不可分割的（原子的）

    。 

  - To truly solve the mutual exclusion problem, the operation of testing and setting the shared variable (e.g., testing a lock and acquiring it) **must be indivisible (atomic)**. 