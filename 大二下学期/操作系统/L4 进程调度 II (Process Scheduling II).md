# L4 进程调度 II (Process Scheduling II)

* **非抢占式调度: 最高响应比优先 (Non-Preemptive HRN Scheduling)**
    * **定义**: 一种非抢占式调度算法，其选择基于响应比。
    * **响应比公式**: 响应比 = (等待时间) / (服务时间)。
    * **示例分析**:
        * **工作负载**:
            * P1: 到达时间 0, CPU Burst 24
            * P2: 到达时间 0, CPU Burst 3
            * P3: 到达时间 0, CPU Burst 3
            * P4: 到达时间 5, CPU Burst 5
            * P5: 到达时间 10, CPU Burst 3
        * **调度过程**:
            * **Time 0**: P2被选中 (响应比为 $0^+/3$)
            * **Time 3**: P3被选中 (响应比为 $3/3$)
            * **Time 6**: P1被选中 (响应比为 $6/24$)
            * **Time 30**: P5被选中 (响应比为 $20/3$)
            * **Time 33**: 最后的作业 P4 被调度。
        * **最终顺序 (Gantt Chart)**: P2 -> P3 -> P1 -> P5 -> P4

* **抢占式调度: 轮转法 (Preemptive Scheduling using Round Robin - RR)**
    * **定义**:
        * 是多任务系统中调度算法的基础。
        * 为所有进程提供良好的响应时间，这对于实现满意的交互性能很重要。
        * 是 FCFS 的抢占式版本。
    * **机制**:
        * 每个进程按顺序执行，直到其**时间片 (quantum)** 用完，然后强制进行任务上下文切换。
        * 可以改变时间片的大小，以便为特定工作负载获得最佳结果。
    * **性能分析 (Quantum 影响)**:
        * **示例工作负载**: P1 (24), P2 (3), P3 (3)
        * **当 Quantum = 1**:
            * 平均等待时间: 5.666
            * 平均响应时间: 1
            * 平均周转时间: 15.666
        * **当 Quantum = 3**:
            * 平均等待时间: 5
            * 平均响应时间: 3
            * 平均周转时间: 15
            * 将时间片与CPU突发时间的平均长度相匹配，改善了一些性能标准。
    * **时间片大小的权衡**:
        * RR算法比非抢占式算法导致更多的任务切换。
        * 每次任务切换都需要CPU花费一定时间来改变进程环境。
        * 时间片太小，会导致CPU时间的更大部分用于任务切换而不是有效工作。
        * 时间片太大，RR算法会退化为FCFS，导致响应时间变差。

* **其他调度技术 (Other Scheduling Techniques)**
    * **多级反馈队列 (Multilevel Feedback Queues)**
        * **目的**: 当作业的平均CPU突发时间差异很大时，很难为所有作业选择一个合适的时间片。
        * **方法**:
            * 这是一种自适应方法，从长远来看可以减少任务切换的开销。
            * 进程最初被提交到顶级的最高优先级队列，以获得良好的响应时间。
            * 如果一个进程随时间表现出计算密集型，它可能被降级到较低优先级的队列。
            * 较低优先级的队列有更合适的CPU时间片长度，从而减少任务切换，但该队列可能获得较少的处理器关注。
    * **优先级调度 (Priority Scheduling)**
        * **问题**: RR 不允许用户告诉系统哪些任务更重要。
        * **方法**:
            * 为进程分配一个数值，该数值表示其调度优先级。
            * 用户可以指定一个任务相对于其他任务的优先级。
            * 调度程序总是首先选择具有最高优先级的进程。
        * **挑战**: 这是一个易于实现的方案，但需要一种计算优先级的方法，以防止低优先级任务饿死。

* **案例研究 (Case Studies)**
    * **传统 Unix 调度器 (The Traditional Unix Scheduler)**
        * **设计目标**:
            * 支持单处理器、单用户环境下的分时、多任务、交互式环境。
            * 最初并非为实时进程需求、多用户或对称多处理而设计。
            * 大约自2003年以来，现代Unix实现已进行了改进以满足这些需求。
        * **特性**:
            * 为交互式用户任务提供良好的响应时间，同时确保低优先级后台任务不会饿死，并能快速完成高优先级系统任务。
            * 采用多级反馈方法，使用轮转法为优先级队列服务。
            * 优先级值在0到127之间，数字越小，优先级越高。
            * 优先级0到49用于内核进程，50到127用于用户进程。
        * **优先级计算**:
            * 每隔一秒根据执行历史和基础优先级计算所有系统进程的优先级。
            * 公式: $P_j(i) = Base_j + CPU_j(i)/2 + nice_j$。
            * 最近的CPU使用会通过增加其优先级值来降低进程的调度优先级。
            * 为确保进程最终能被重新调度，每次重新计算优先级时，会使用公式 $CPU_j(i) = CPU_j(i-1)/2$ 来衰减记录的CPU利用率。
    * **公平共享调度 (Fair-Share Scheduling)**
        * **问题**:
            * 在多用户多任务系统中，一个用户或应用程序运行的进程数可能远少于另一个。
            * 到目前为止的调度算法只关注在所有进程中实现公平分配，而不是在不同用户或应用程序之间实现CPU时间的公平分配。
        * **方法**:
            * 该方案需要修改进程优先级计算，以便为每组进程分配一定比例的处理器时间。
            * **修改后的优先级公式**: $P_j(i) = Base_j + CPU_j(i)/2 + GCPU_k(i)/(4 \times W_k)$。
                * $W_k$ 是分配给组 k 的CPU时间权重，$0 < W_k \le 1$，且所有 $W_k$ 的总和为1。
            * 组的CPU使用率也以同样方式衰减: $GCPU_k(i) = GCPU_k(i-1)/2$。
            * 示例: 两个组，每个组的权重为0.5，即平分时间份额。