# 读者写者与哲学家进餐问题

------

### 考试复习资料：经典同步问题

### **第一部分：哲学家就餐问题 (Part 1: The Dining Philosophers Problem)**

#### **1. 问题定义 (Problem Definition)**

这是一个经典的同步问题，旨在说明如何在并发进程间分配有限资源，同时避免**死锁 (deadlock)** 1。

- 场景 (Scenario):

   五位哲学家围坐一桌，交替进行思考和吃饭 。

   桌上有五根筷子，每位哲学家吃饭时都需要同时使用其左右手边的两根筷子 。

------

#### **2. 初步（有缺陷的）解决方案 (Initial Flawed Solution)**

- **策略 (Strategy):** 将每根筷子视为一个二进制信号量，初始值为1（可用） 4444。每个哲学家都先尝试获取他左边的筷子，然后再尝试获取右边的筷子 5。

  

  

- **代码实现 (Code Implementation):**

  Java

  ```
  // 哲学家 i 的行为
  // Behavior of philosopher i
  while (true) {
      think();
  
      // 等待并获取左边的筷子 
      // Wait for and acquire the left chopstick 
      chopstick[i].acquire();
  
      // 等待并获取右边的筷子 
      // Wait for and acquire the right chopstick 
      chopstick[(i + 1) % 5].acquire();
  
      eat();
  
      // 释放两根筷子
      // Release both chopsticks
      chopstick[i].release();
      chopstick[(i + 1) % 5].release();
  }
  ```

- **缺陷 (Flaw): 死锁 (Deadlock)**

  - 如果所有五位哲学家恰好在同一时间都拿起了他们左边的筷子，那么他们每个人都将因为等待右边的筷子而被永远阻塞 6

    。这种情况被称为死锁 

------

#### **3. 无死锁的解决方案 (Deadlock-Free Solutions)**

##### **方法一：避免死锁 - 限制并发 (Method 1: Deadlock Avoidance - Restricting Concurrency)**

- **策略 (Strategy):** 最多只允许四位哲学家同时坐在桌旁（即同时尝试获取筷子）8。这能确保至少有一位哲学家最终能获得两根筷子，从而打破死锁的可能 9。

  

- **代码实现 (Code Implementation):** 使用一个初始值为4的计数信号量 `room` 10。

  Java

  ```
  // 使用 "room" 信号量
  // Using the "room" semaphore
  room.acquire(); // 进入房间
  
  chopstick[i].acquire();
  chopstick[(i + 1) % 5].acquire();
  
  eat();
  
  chopstick[i].release();
  chopstick[(i + 1) % 5].release();
  
  room.release(); // 离开房间
  ```

- **缺点 (Drawback):** 为了避免一个潜在的死锁，此方案降低了系统的潜在并发度，从而可能降低系统吞吐量 

- This scheme reduces the potential concurrency in order to avoid a 
  potential deadlock situation occurring and therefore system 
  throughput is reduced on the chance that a deadlock may occur.。

  

  

##### **方法二：预防死锁 - 破坏“占有并等待” (Method 2: Prevention - Breaking "Hold and Wait")**

- **策略 (Strategy):** 要求哲学家必须**同时**获得两根筷子，否则一根也不拿 。这可以通过一个互斥锁 `mutex` 来保护检查和获取两根筷子的操作，使其成为一个原子操作 13。

  

  

- **代码实现 (Code Implementation):**

  Java

  ```
  // 共享一个互斥锁 mutex 
  // A shared mutex semaphore 
  boolean haveChopsticks = false;
  while (!haveChopsticks) {
      mutex.acquire(); // 获取互斥锁
  
      // 检查两根筷子是否都可用 
      // Check if both chopsticks are available 
      if ((chopsticks[myName] == 1) && (chopsticks[(myName + 1) % 5] == 1)) {
          chopsticks[myName] = 0;
          chopsticks[(myName + 1) % 5] = 0;
          haveChopsticks = true;
      }
  
      mutex.release(); // 释放互斥锁
  }
  // ... eat() and release chopsticks ...
  ```

- **缺点 (Drawbacks):**

  - 对于需要**大量资源**的进程，一次性获取所有资源可能很困难 （In reality, it would be difficult for a process, especially **one with** **large resource requirements,** to acquire all of its resources at the same time before it could do any work. ）。
  - 此方案存在忙等待 (busy waiting)，线程会持续循环尝试获取锁，浪费CPU资源 。（Also there is busy waiting in our solution where the while loop  continually attempts to acquire the mutex and test the chopstick  array until the thread has its chopsticks.）

##### **方法三：预防死锁 - 破坏“循环等待” (Method 3: Prevention - Breaking "Circular Wait")**

- **策略 (Strategy):** 采用非对称方案 16。让奇数号哲学家先拿左筷再拿右筷，而偶数号哲学家反之 17。这破坏了所有哲学家请求资源的顺序一致性，从而避免了循环等待 18。

  

  

- **代码实现 (Code Implementation):**

  Java

  ```
  if ((myName % 2) == 0) { // 偶数号哲学家
      chopstick[myName].acquire();         // 先拿左筷 
      chopstick[(myName + 1) % 5].acquire(); // 再拿右筷 
  } else { // 奇数号哲学家
      chopstick[(myName + 1) % 5].acquire(); // 先拿右筷
      chopstick[myName].acquire();         // 再拿左筷
  }
  ```

- **缺点 (Drawback):** 这是一个“特别的”(ad hoc)解决方案，虽然在此场景有效，但很难推广到其他资源调度问题中 （This is an ad hoc solution and can be seen to work for this concurrency scenario but is difficult to apply generally. A similar such solution may not be obvious in a typical resource scheduling situation.）

#### **4. 问题总结 (Overall Summary)**

- （最初的方法共享筷子资源，但是可能导致死锁）Our original solution shared the chopstick resources properly but 
  was susceptible to deadlock.
- （提出的替代性方法可以避免死锁，但是以限制资源利用率表现或者不对大进程友好为代价）Alternative methods were proposed to avoid or prevent deadlock, 
  but came at the cost of restricting resource usage performance or 
  discriminating against larger processes.
- （没有一种方法可以保证不公平的进程调度导致的饥饿）None of the solutions make any guarantees about starvation
  which may occur due to unfavourable scheduling or conspiracy.
- （一个更好的解决方案可能会试图解决这个问题，并给每个哲学家一个公平的分配时间）An even better solution might attempt to deal with that and giving a fair allocation of chopstick time to each philosopher.

------

------

### **第二部分：读者-写者问题 (Part 2: The Readers/Writers Problem)**

#### **1. 问题定义 (Problem Definition)**

- 场景 (Scenario):

   多个并发线程访问一个共享数据区 。

  - 读者 (Reader):

     只读取数据，不修改 。

  - 写者 (Writer):

     修改数据 。

- 约束 (Constraints):

  - 允许多个读者同时并发访问 。
  - 写者在访问时必须独占，不能有任何其他读者或写者 。

------

#### **2. 两种主要策略 (Two Main Policies)**

1. 第一类问题：读者优先 (First Problem: Readers' Priority)
   - 策略:任何读者都不应被等待，除非一个写者已经获得了访问许可 。
2. 第二类问题：写者优先 (Second Problem: Writers' Priority)
   - 策略:一旦一个写者准备就绪，它应该尽快完成写操作，这可能需要让后来的读者等待 28。

------

#### **3. 读者优先解决方案 (Solution for Readers' Priority)**

- **组件 (Components):**

  - 

    ```
    readerCount
    ```

     (整数): 记录当前正在读取的读者数量 29

    。

  - 

    ```
    mutex
    ```

     (信号量，初值为1): 用于保护对 

    ```
    readerCount
    ```

     的修改，确保其原子性 30

    。

  - 

    ```
    wrt
    ```

     (信号量，初值为1): 用于实现写者互斥，同时也供“第一个”读者和“最后一个”读者使用来阻塞/允许写者 31

    。

- **代码实现 (Code Implementation):**

  Java

  ```
  // 构造函数
  public DataAccessPolicyManager() {
      readerCount = 0;
      mutex = new Semaphore(1);
      wrt = new Semaphore(1);
  }
  
  // 读者获取锁 
  public void acquireReadLock() {
      mutex.acquire();
      ++readerCount;
      if (readerCount == 1) { // 如果是第一个读者 
          wrt.acquire(); // 则阻塞写者 
      }
      mutex.release();
  }
  
  // 读者释放锁 
  public void releaseReadLock() {
      mutex.acquire();
      --readerCount;
      if (readerCount == 0) { // 如果是最后一个读者 
          wrt.release(); // 则允许写者进入 
      }
      mutex.release();
  }
  
  // 写者获取锁 
  public void acquireWriteLock() {
      wrt.acquire();
  }
  
  // 写者释放锁 
  public void releaseWriteLock() {
      wrt.release();
  }
  ```

------

#### **4. 写者优先解决方案 (Solution for Writers' Priority)**

- **核心思想 (Core Idea):** 当一个写者准备写入时，它必须能够阻止任何**新**的读者开始读取，直到自己完成写入 32。

  

  

- **组件 (Components):** 需要更多的数据结构，包括 `writeCount`, `mutexWriteCount`, 和一个额外的信号量 `rdr` (初值为1) 来阻塞读者 

  

  

- **代码实现 (Code Implementation):**

  Java

  ```
  // 写者获取锁 
  public void acquireWriteLock() {
      mutexWriteCount.acquire();
      ++writeCount;
      if (writeCount == 1) { // 如果是第一个写者 
          rdr.acquire(); // 则阻塞新来的读者 
      }
      mutexWriteCount.release();
  
      wrt.acquire(); // 等待现有读者或写者 
  }
  
  // 写者释放锁 
  public void releaseWriteLock() {
      wrt.release();
  
      mutexWriteCount.acquire();
      --writeCount;
      if (writeCount == 0) { // 如果是最后一个写者 
          rdr.release(); // 则允许读者进入 
      }
      mutexWriteCount.release();
  }
  
  // 读者获取锁 (部分代码) 
  public void acquireReadLock() {
      rdr.acquire(); // 尝试通过读者"门"
      // ... (与读者优先方案类似，使用 readCount 和 wrt)
      rdr.release(); // 允许下一个实体竞争
  }
  ```

- **潜在问题与改进 (Potential Issue & Refinement):**

  - 该方案中，读者和写者都会竞争 

    ```
    rdr
    ```

     信号量 

    。如果读者很多，写者可能难以获取 

    ```
    rdr
    ```

    ，从而违背了写者优先的策略 。

  - 

    改进:

     可以增加另一个互斥锁 

    ```
    mutexContentionGate
    ```

    。读者在尝试获取 

    ```
    rdr
    ```

     之前，必须先获取这个门锁。这可以确保任何时候只有一个读者在等待 

    ```
    rdr
    ```

    ，从而减少了与写者的竞争 。