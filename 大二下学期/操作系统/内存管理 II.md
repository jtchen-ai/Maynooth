### 内存管理 II

#### 1. 进程地址空间回顾（Process Address Space Recall）

一个进程的地址空间主要分为三个区域：

- **文本区（Text）**：存放程序的代码，通常是静态的。

- 栈区（Stack）

  ：

  - 固定大小的内存区域，用于函数调用时创建栈帧，存放参数、局部变量和返回地址。
  - 栈帧按 “后进先出（LIFO）” 方式在栈顶添加和移除，分配回收速度快。
  - 每个线程拥有独立的栈，但共享同一个堆。

- 堆区（Heap）

  ：

  - 可变大小的内存区域，用于创建动态数据结构和对象。
  - 堆上的变量在函数调用返回后仍存在，与栈变量不同。
  - 堆的线性空间管理更复杂，耗时更长。

#### 2. 动态分区与线性内存管理（Dynamic Partitioning & Linear Memory Management）

##### 基本操作

- **分配（Allocation）**：内存管理器找到并分配足够大的空闲空间以满足请求。
- **回收（Deallocation）**：将已分配的内存空间收回并归还到空闲区域。

##### 跟踪空闲空间的方法

- **位图法（Bit Maps）**

  - 原理

    ：

    - 将内存划分为固定大小的分配单元（如 1KB），位图中每个比特位对应一个单元，“1” 表示已用，“0” 表示未用。

  - 开销与权衡

    ：

    - 位图大小取决于内存空间和分配单元大小。
    - 分配单元过大：位图变小，但可能导致内部碎片（最后一个单元浪费空间）。
    - 分配单元过小：大内存场景下，位图本身占用空间大，搜索耗时。

  - 操作效率

    ：

    - 分配：搜索连续的 “0” 位以满足请求。
    - 回收：重置对应比特位。

- **链表法（Linked Lists）**

  - 原理

    ：

    - 维护链表记录每个可变大小空闲块的大小和位置，记录可存储在未使用区域的头字节。

  - 放置算法

    ：

    - **最佳适配（Best Fit）**：将进程放入能容纳它的最小空闲块。
    - **最差适配（Worst Fit）**：放入最大空闲块，分割后保留较大剩余块。
    - **首次适配（First Fit）**：分配第一个足够大的空闲块。
    - **下次适配（Next Fit）**：从上次分配位置开始，使用首次适配搜索。

  - 操作效率

    ：

    - 分配：搜索链表找到合适空闲块。
    - 回收：添加新记录到空闲列表，并合并相邻空闲块以减少碎片。

- **伙伴系统（Buddy System）**

  - 原理

    ：

    - 允许动态分区，但限制分区大小为 2 的幂次方，简化分配和回收。
    - 维护大小为 2 的幂次方的空闲块列表，分配请求映射到最接近的块大小。

#### 3. 页式架构（Paged Architecture）

##### 核心思想

- 内存划分为固定大小的 “页（pages）”（如 512-8KB），进程地址空间由多个页组成。
- 进程分配的物理页无需连续，克服动态分区的碎片问题，但需硬件（MMU）支持。

##### 地址转换

- 内存地址分为**页号（Page Number）** 和**页内偏移（Offset）**。
- 每个进程拥有**页表（Page Table）**，内存管理单元（MMU）通过页表将逻辑地址中的页号转换为物理页号。

##### 优缺点

- 优点

  ：

  - **保护**：进程无法访问其他进程的地址空间，因页表不包含对应指针。
  - **灵活性**：物理页可随机分布，便于跟踪空闲和已分配空间。
  - **重定位 / 扩展**：通过修改页表映射，轻松重定位或扩展进程地址空间。

- 缺点

  ：

  - **开销**：页表可能很大，需存储在主存中。
  - **性能**：每次内存访问可能需两次物理访问（查页表 + 取数据），需 TLB 缓存优化。
  - **内部碎片**：进程最后一页未使用部分被浪费，平均浪费半个页。

#### 4. 请求调页与虚拟内存（Demand Paging & Virtual Memory）

##### 核心思想

- 仅将进程中与当前**引用局部性（locality of reference）** 相关的页存入内存，允许虚拟地址空间超过物理内存容量。
- 减少每个进程分配的页数，提高多道程序设计程度。

##### 实现机制

- 硬盘上使用**交换文件（swap file）** 存储所有进程的逻辑页，内存管理器仅将**工作集（working set）** 调入物理内存。

##### 页表修改

- 页表条目增加**有效 / 无效位（valid/invalid bit）**，标记页是否在内存中。

##### 缺页中断（Page Fault）

- 当 MMU 访问无效页时触发，处理流程：
  1. 操作系统捕获中断。
  2. 在硬盘后备存储中找到缺失页。
  3. 将页调入空闲物理内存帧。
  4. 重置页表，标记页为 “有效”。
  5. 重新执行被中断的指令。

##### 页面置换算法（Page Replacement Algorithms）

- **动机**：内存无空闲页时，选择一页换出到磁盘，为新页腾出空间。

- 效率考量

  ：

  - 频繁缺页中断会降低内存访问速度，导致磁盘繁忙。
  - 工作集过小时，页频繁在内存和磁盘间交换，引发**颠簸（thrashing）**。

- 常见算法

  ：

  - **最佳算法（Optimal）**：替换未来最长时间未使用的页（理论上无法实现）。
  - **先进先出（FIFO）**：替换在内存中停留时间最长的页。
  - **最近最少使用（LRU）**：替换最长时间未被访问的页。
  - **最不经常使用（LFU）**：替换过去引用次数最少的页。

- Belady 异常（Belady's Anomaly）

  ：

  - 对于 FIFO 等算法，增加分配的页帧数可能反而导致缺页次数增加，与直觉相悖。





