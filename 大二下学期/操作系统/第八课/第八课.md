# 第八课



如果某些进程 分层创建 写在同一台机器运行 ，他们可以使用基于 蒸汽通信机制 的快速内核 它叫做 管道



管道是采取先进先出 FIFO 的流通信 通道 基于内核里面有限大小的 memory buffer 实现



一个进程在管道的末端写入数据，而且另一个进程通常在管道的另一端阅读该数据。 管道始终存在如**果存活的进程可以访问它**



一个管道只能被相关进程共同使用 而且 经常被作为 从**父进程到子进程**的单向交互通道等等。父进程通常在创建子进程之前创建管道以确保子进程可以继承，并访问该管道



管道调用的语法可以被表示为

**pipe(fdptr);**



fdotr 是一个指向包含两个数组的整数的指针







系统被调用到管道之后 这个数组将会包含两个可以辨识新管道两端的文件描述符



fdptr[0] 是管道的 read 标识符 fdptrp[1]是写标识符



处理 I/O 设备的细节被记录在 进程标识符表

 

需要的数据结构：

int fdptr[2],n

char strbuff[5]



pipe(fdptr)





如果管道是空的 阅读功能 **阻塞进程的调用** 直到管道中有数据可以读取



如果管道不是空的 但是进程要读取相比于管道中更多的数据，将会成功读取管道中所有数据以及实际读取的字节计数



命名管道

管道机制的另一种表现形式叫做命名管道，可以被运用到无关联的进程通信，如果这些进程拥有相同的**文件名空间**



一个命名管道可以通过 kernel 被实现为特定的先进先出FIFO 文件  ,而不是回放缓冲池 所以所以它可以运用到 相互独立的 共享 name space 的 进程中





命名管道可以通过共同的文件系统在机器间 被 共享



进程通过和 regular files 一样的方式打开命名管道 所以无关的 进程 可以通过打开该管道进行读写



**语义**

一个打开管道获取读权限的进程会阻塞如果没有为了获取写权限而打开管道的进程



相似的 同理可得



n=read(namepiple,buffer,nbytes)



write(namepipe,buffer,ntypes)



Sockets 无关联进程之间通信比较常见的手段，当kernel 数据结构或者文件都无法共享的时候 socket 可以派上用场



 例如 在互联网之间通信



一个通信通道可以被视为一对通信端点



Socket 是一个由应用创建的 数据结构，用来表示通信管道Socket 必须被 限制宽度 或者与某些在通信系统中的实体关联，通过使用 socket 接口的通信基元 进程可以与相对的通信子系统交换信息 该子系统 掌控信息传输



通信服务 TIP协议/IP 协议 提供  建立 不同进程的socket 之间通信的桥梁 这些socket 通常存在于不同的机器，通过网络传输数据到终点

在网络中 IP 地址还有端口号 被作为 辨识 终端的手段





能够理解相同通信协议的通信子系统必须沿着网络中的每个点运行 





消息可靠性级别的强弱 可以由TCP 协议来指定

速度更快的传递 可靠性更低

数据报与连接以套接字为导向的连接可以通过基础通信协议“连接”到任何指定的远程套接字。连接后，将发送到本地插座的字节将传递到远程套接字。远程进程“听”到其插座，并接收到发送到字节流的数据



Socket 可以通过**底层通信协议**“连接”到任何命名的远程 Socket。连接后，发送到本地 Socket 的字节被传递到远程 Socket。远程进程 “监听” 其Socket，并接收发送到字节流中的数据。