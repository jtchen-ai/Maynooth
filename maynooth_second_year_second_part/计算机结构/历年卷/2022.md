# 2022

## Question1

好的，我们来详细解答这份2021-2022学年Maynooth大学计算机体系结构2 (CS253FZ) 试卷的第一大题 (QUESTION 1)。

------

### **中文详细解答**

#### **(a) 为代码框中的项目选择名称**

此部分要求将术语与代码中的标号匹配。

- 

  (i) A -> 汇编器指令 (assembler directives)

   11

  A框中的 

  ```
  .MODEL
  ```

  , 

  ```
  .STACK
  ```

  , 

  ```
  .DATA
  ```

   等是指导汇编器如何工作的命令，而不是CPU指令。

- 

  (ii) B -> 标签 (labels)

   2222

  B框指向的 

  ```
  next:
  ```

   和代码下方的 

  ```
  done:
  ```

   是程序中用于跳转指令的目标地址标记。

- 

  (iii) C -> 操作数 (operands)

   3

  C框指向的 

  ```
  d1,020h
  ```

   是 

  ```
  sub
  ```

   指令的操作对象，即操作数。

- 

  (iv) D -> 机器指令 (machine instructions)

   4

  D框指向的 

  ```
  72 XX
  ```

   是 

  ```
  jb
  ```

   指令的十六进制机器码表示。

- **(v) E -> 助记符 (mnemonics)** E框指向的 `mov ah, 08h` 这一行中，`mov` 是指令的助记符。在给出的选项中，`operators` 最接近助记符的含义，但“助记符”是更标准的术语。

#### **(b) 助记符 (mnemonics) 和操作码 (opcodes) 的主要区别** 5

- **助记符 (Mnemonics)**：是人类可读的指令名称，例如 `MOV`, `ADD`, `SUB`。它们是为**程序员**设计的，便于记忆和编写代码。
- **操作码 (Opcodes)**：是CPU能够直接理解和执行的二进制或十六进制**机器码**。它们是为**CPU**设计的。
- **关系**：汇编器 (Assembler) 的作用就是将程序员写的助记符翻译成CPU能懂的操作码。

#### **(c) 按键时会显示哪些字符？** 6

程序逻辑如下：

1. 读取一个按键的ASCII码到 `al`，并复制到 `dl`。
2. `cmp d1,061h` 和 `jb next`：检查输入字符是否小于 `'a'` (ASCII `61h`)。如果是，则跳过处理。
3. `cmp d1,07Ah` 和 `jnb next`：检查输入字符是否大于 `'z'` (ASCII `7Ah`)。如果是，则跳过处理。
4. 综上，只有**小写字母'a'到'z'**会被处理。
5. `sub d1,020h`：对于被处理的小写字母，减去`20h`将其转换为**大写字母**。
6. `int 021h`：显示转换后的大写字母。
7. `cmp dl, 'Q'` 和 `je done`：检查显示的大写字母是否为'Q'。如果是，则程序终止。

根据输入字符串 `abc123PQR@#$pqr`：

- `abc` -> 被转换为 `ABC` 并显示。
- `123` -> ASCII码小于`61h`，跳过。
- `PQR` -> ASCII码小于`61h`，跳过。
- `@#$` -> ASCII码小于`61h`，跳过。
- `p` -> 被转换为 `P` 并显示。
- `q` -> 被转换为 `Q` 并显示。显示'Q'之后，`cmp dl, 'Q'` 条件成立，程序跳转到 `done` 并终止。
- `r` -> 不会被处理。

因此，屏幕上会在程序终止前显示：**ABCPQ**

#### **(d) 确定XX和YY的十六进制值** 7

这部分考察相对跳转地址的计算。公式为：`相对偏移量 = 目标地址 - 当前指令的下一条指令地址`。

- 计算XX (`jb next`)
  - `jb next` 指令位于偏移地址 `0020h`，占2个字节。
  - 下一条指令的地址是 `0022h`。
  - 目标地址 `next` 的偏移量是 `0017h`。
  - 偏移量 = `0017h - 0022h = -0Bh`。
  - -11 (十进制) 的8位补码是 `F5h`。所以 **XX = F5h**。
- 计算YY (`je done`)
  - `je done` 指令位于偏移地址 `0031h`，占2个字节。
  - 下一条指令的地址是 `0033h`。
  - 目标地址 `done` 的偏移量是 `0035h`。
  - 偏移量 = `0035h - 0033h = 02h`。
  - 所以 **YY = 02h**。

#### **(e) 计算指令的起始物理地址** 8

物理地址的计算公式为：`物理地址 = (段地址 × 16) + 偏移地址`。

- 给定的代码段寄存器 (CS) 地址是 `12EFh`。
- `cmp dl, 'Q'` 指令的偏移地址是 `002Eh`。
- 物理地址 = `(12EFh × 10h) + 002Eh = 12EF0h + 002Eh = 12F1Eh`。
- 因此，该指令在主内存中的起始地址是 **12F1Eh**。

#### **(f) 边沿触发和电平触发D触发器的主要区别** 9

- **电平触发 (Level-triggered)**：也称为锁存器 (latch)。当其时钟/使能信号处于某个特定电平（例如高电平）时，输出 `Q` 会**持续地**跟随输入 `D` 的变化。它在整个有效电平期间都是“透明”的。
- **边沿触发 (Edge-triggered)**：输出 `Q` **仅在**时钟信号发生特定跳变（从低到高的上升沿，或从高到低的下降沿）的**瞬间**才会根据输入 `D` 的状态更新。在时钟的其他时间里，即使输入`D`变化，输出也会保持不变。

#### **(g) 静态内存(SRAM)与动态内存(DRAM)的区别及缓存的作用**

- 

  (i) 静态内存和动态内存的三个区别

   10

  1. **基本单元**：SRAM使用由多个晶体管（通常是6个）组成的触发器来存储一个比特。DRAM使用一个晶体管和一个电容器来存储一个比特。
  2. **刷新要求**：DRAM的电容器会漏电，因此必须周期性地刷新（重新充电）以保持数据。SRAM只要有电，就能一直保持数据，不需要刷新。
  3. **速度与成本**：SRAM的结构更复杂，但速度非常快。DRAM结构简单，密度高，成本低，但速度比SRAM慢。

- 

  (ii) 缓存如何帮助加速程序执行？

   11

  缓存（通常用SRAM实现）是位于CPU和主内存（DRAM）之间的一小块高速存储器。它利用了

  局部性原理

  （程序倾向于在短期内重复访问同一块数据和指令）。当CPU需要数据时，它首先检查缓存：

  - **缓存命中 (Hit)**：如果数据在缓存中，CPU可以直接高速获取，节省了大量时间。
  - **缓存未命中 (Miss)**：如果数据不在缓存中，CPU会从较慢的主内存中读取，并同时将该数据块复制到缓存中，以便下次快速访问。 由于缓存命中率通常很高，平均内存访问时间被大大缩短，从而显著提升了程序执行速度。

#### **(h) ROM, PROM, EPROM, 和 EEPROM 的区别** 12

- (i) ROM 与 PROM 的区别
  - **ROM (Read-Only Memory)**：只读存储器。数据在**制造时**通过掩模工艺固化在芯片中，用户无法更改。
  - **PROM (Programmable ROM)**：可编程只读存储器。出厂时是空白的，用户可以使用专用设备**一次性**写入数据。
- (ii) PROM 与 EPROM 的区别
  - **PROM**：只能写入一次。
  - **EPROM (Erasable PROM)**：可擦除可编程只读存储器。可以通过**紫外线光**照射芯片上的石英窗口来擦除全部数据，然后可以重新编程。
- (iii) EPROM 与 EEPROM 的区别
  - **EPROM**：擦除需要使用紫外线设备，且是整片擦除，过程不便。
  - **EEPROM (Electrically Erasable PROM)**：电可擦除可编程只读存储器。可以**在电路中**通过施加电信号来擦除和重写数据，通常可以按字节进行操作，比EPROM灵活方便得多。现代的闪存（Flash Memory）就是基于EEPROM技术发展的。

------

### **English Summary (Key Points)**

**(a) Matching Terms** 13131313



- **(i) A -> assembler directives**: e.g., `.MODEL`, `.STACK`.
- **(ii) B -> labels**: e.g., `next:`.
- **(iii) C -> operands**: e.g., `d1,020h`.
- **(iv) D -> machine instructions**: e.g., `72 XX`.
- **(v) E -> mnemonics/operators**: e.g., `mov`.

**(b) Difference between mnemonics and opcodes** 14



- **Mnemonics**: Human-readable instruction names (for programmers).
- **Opcodes**: Machine-readable binary/hex codes (for the CPU).
- An assembler translates mnemonics into opcodes.

**(c) What appears on the screen?** 15



- The program converts lowercase letters ('a'-'z') to uppercase and prints them.
- It terminates when the *output* character is 'Q'.
- Input `abc123PQR@#$pqr` results in **ABCPQ** being printed before termination.

**(d) Hexadecimal values of XX and YY**

- **XX (`jb next`)**: Jump from `0022h` (next instruction addr) to `0017h`. Offset = `17h - 22h = -0Bh`. 8-bit 2's complement is **F5h**.
- **YY (`je done`)**: Jump from `0033h` to `0035h`. Offset = `35h - 33h = 02h`. So, **YY = 02h**.

**(e) Physical address of `cmp dl, 'Q'`** 17



- Formula: `(CS * 10h) + Offset`.
- `CS = 12EFh`, `Offset = 002Eh`.
- Address = `(12EFh * 10h) + 002Eh` = **12F1Eh**.

**(f) Edge-triggered vs. Level-triggered D Flip-flop** 18



- **Level-triggered (Latch)**: Output `Q` follows input `D` as long as the clock is at an active *level* (e.g., high).
- **Edge-triggered**: Output `Q` updates to `D` only at the *instant* of a clock's rising or falling *edge*.

**(g) SRAM vs. DRAM & Caching**

- 

  (i) Three differences between Static (SRAM) and Dynamic (DRAM) memory

   19

  1. **Structure**: SRAM uses flip-flops (~6 transistors/bit); DRAM uses a capacitor and transistor (1T1C).
  2. **Refresh**: DRAM requires periodic refreshing; SRAM does not.
  3. **Performance/Cost**: SRAM is much faster but more expensive and less dense than DRAM.

- 

  (ii) How caching speeds up execution

   20

  Caches (fast SRAM) store frequently used data from slower main memory (DRAM). They work on the 

  principle of locality

  . When data is found in the cache (a 

  hit

  ), access is very fast. This reduces the average memory access time, speeding up the CPU.

**(h) Differences between ROM types** 



- **(i) ROM vs. PROM**: **ROM** is mask-programmed at the factory. **PROM** is programmed once by the user.
- **(ii) PROM vs. EPROM**: **PROM** is one-time programmable. **EPROM** can be erased with UV light and reprogrammed.
- **(iii) EPROM vs. EEPROM**: **EPROM** requires UV light for a full-chip erase. **EEPROM** can be erased and reprogrammed electrically, in-circuit, often byte-by-byte.

## Question2

### **中文解答**

#### **(a) 题：指令与寻址**

**(i) 每条指令需要多少位？**  CPU是4位的 ，处理4位的数据 。一条指令由操作码（Opcode）和操作数（Operand）组成。

- 操作码

  : 需要编码3个信息：S2（寻址模式），S1和S0（ALU操作） 

  。这需要3位。我们可以假设操作码被填充为4位（一个存储单元大小），例如 

  ```
  0 S2 S1 S0
  ```

  。

- 

  操作数

  : 操作数B或地址也是4位的 

  。 因此，一条完整的指令（操作码+操作数）需要占用两个4位的存储单元，共 

  8 位

  。

**(ii) 这个CPU能直接寻址多少个内存位置？**  直接寻址模式下，操作码后面跟着的是一个地址 。因为这是一个4位CPU，地址也使用4位表示。因此，CPU能寻址的内存位置数量为 24=textbf16 个（从地址0到15）。



#### **(b) 题：获取机器码**

我们需要将汇编指令转换为十六进制的机器码（操作码+操作数）。 操作码由 `S2 S1 S0` 决定，我们假设格式为 `0 S2 S1 S0`。

- **`XOR @8`**:

  - 操作是 

    ```
    XOR
    ```

    ，对应MUX的D2输入，所以 

    ```
    S1S0 = 10
    ```

    。 

  - 寻址模式是直接寻址（由

    ```
    @
    ```

    符号表示 

    ），所以 

    ```
    S2 = 0
    ```

    。 

  - 操作码位 `S2 S1 S0` 为 `0 1 0`。完整操作码为 `0010` (二进制)，即 **`2h`**。

  - 操作数是地址 `8`，即 **`8h`**。

  - 机器码: **`28h`**

- **`AND 9`**:

  - 操作是 

    ```
    AND
    ```

    ，对应MUX的D1输入，所以 

    ```
    S1S0 = 01
    ```

    。 

  - 寻址模式是立即寻址（没有

    ```
    @
    ```

    符号 

    ），所以 

    ```
    S2 = 1
    ```

    。 

  - 操作码位 `S2 S1 S0` 为 `1 0 1`。完整操作码为 `0101` (二进制)，即 **`5h`**。

  - 操作数是立即数 `9`，即 **`9h`**。

  - 机器码: **`59h`**

#### **(c) 题：追踪代码执行**

**初始内存状态**: `Mem[0]=5`, `Mem[1]=6`, `Mem[2]=7`, `Mem[3]=8`, `Mem[4]=9`。  **累加器 (A)** 的初始值未知，但第一条指令是 `LOAD`，它会覆盖A的值。 



1. **`LOAD @3`** 

   

   

   - 这是一条直接寻址的加载指令。

   - 它会从内存地址

     ```
     3
     ```

     中读取数据。 

   - 

     ```
     Mem[3]
     ```

      的值是 

     ```
     8
     ```

     。 

   - 执行后，累加器 `A` 的值为 **8**。

2. **`ADD 5`** 

   

   

   - 这是一条立即寻址的加法指令。

   - 它将累加器 

     ```
     A
     ```

      的当前值与立即数 

     ```
     5
     ```

      相加。 

   - 运算: A=A+5=8+5=13。

   - 13的十六进制是 `D`。

   - 执行后，累加器 `A` 的值为 **13** (`Dh`)。

3. **`XOR @0`** 

   

   

   - 这是一条直接寻址的异或指令。

   - 它将累加器 

     ```
     A
     ```

      的当前值与内存地址 

     ```
     0
     ```

      的值进行异或运算。 

   - 

     ```
     Mem[0]
     ```

      的值是 

     ```
     5
     ```

     。 

   - 运算: A=Aoplus5=13oplus5。

   - 二进制运算: `1101` (13) oplus `0101` (5) = `1000`。

   - `1000` (二进制) 是 `8` (十进制)。

   - 执行后，累加器 `A` 的值为 **8**。

最终，累加器中存储的值是 **8**。

#### **(d) 题：计算二进制补码**

要计算数字7的二进制补码（Two's Complement），我们需要执行 `(NOT 7) + 1` 的操作。

- **NOT 7**: 可以通过将7与`1111b`（即`Fh`或十进制15）进行异或（XOR）运算来实现。
- **+ 1**: 使用`ADD`指令加1。

**代码如下**:

Code snippet

```
LOAD 7      ; 将立即数7加载到累加器A
XOR 15      ; 将A与立即数15(Fh)进行异或，实现按位取反
ADD 1       ; 将A与立即数1相加，完成补码计算
```

------

### **English Summary (Key Points)**

- **(a) Instruction Size & Address Space**

  - 

    (i)

     Each instruction requires 

    8 bits

     (4 bits for the opcode, 4 for the operand/address). 

  - 

    (ii)

     The CPU can directly address 

    16 memory locations

     (

    24

    ), as addresses are 4 bits long. 

- **(b) Machine Code**

  - 

    ```
    XOR @8
    ```

    : 

    `28h`

     (Opcode for direct XOR is 

    ```
    2h
    ```

    , address is 

    ```
    8h
    ```

    ). 

  - 

    ```
    AND 9
    ```

    : 

    `59h`

     (Opcode for immediate AND is 

    ```
    5h
    ```

    , value is 

    ```
    9h
    ```

    ). 

- **(c) Code Execution Trace**

  - The initial memory values are given. 

  - 

    ```
    LOAD @3
    ```

     sets Accumulator 

    ```
    A
    ```

     to the value at address 3, so 

    ```
    A = 8
    ```

    . 

  - 

    ```
    ADD 5
    ```

     adds the immediate value 5 to 

    ```
    A
    ```

    , so 

    ```
    A = 8 + 5 = 13
    ```

    . 

  - 

    ```
    XOR @0
    ```

     XORs 

    ```
    A
    ```

     with the value at address 0, so 

    ```
    A = 13 XOR 5 = 8
    ```

    . 

  - The final value in the accumulator is **8**.

- **(d) Two's Complement of 7**

  - To get the two's complement (`NOT 7 + 1`), the following code can be used:

  <!-- end list -->

  Code snippet

  ```
  LOAD 7      ; A = 7
  XOR 15      ; A = A XOR 15 (bitwise NOT)
  ADD 1       ; A = A + 1
  ```



## Question3



好的，我将为你解答这份关于英特尔8086处理器的计算机体系结构问题。

这份题目考察了计算机系统基础中的几个核心概念：数据在内存中的存储方式（大小端）、浮点数的二进制表示法（IEEE 754）、汇编语言中的数据定义以及8086处理器的分段内存寻址机制。

------

### **中文解析**

#### **(a) 简要解释大端和小端数据存储约定的主要区别。(3分)**

**核心概念**：大端(Big-Endian)和小端(Little-Endian)是两种处理多字节数据类型（如 `integer`, `float`）在内存中字节排列顺序的方法。

1. **大端模式 (Big-Endian)**：
   - **定义**：数据的**最高有效字节 (Most Significant Byte, MSB)** 存储在内存的**最低地址**处。后续字节按顺序存储在更高地址。
   - **记忆法**：可以理解为“高位在前”，符合人类阅读和书写数字的习惯（例如，数字1234，我们先读/写最高位的'1'）。
   - **例子**：对于一个32位整数 `0x12345678`，在内存中从低地址到高地址的存储顺序是：`12 56 34 78`。
   - **应用**：常用于网络协议（网络字节序）和一些RISC架构的处理器（如PowerPC）。
2. **小端模式 (Little-Endian)**：
   - **定义**：数据的**最低有效字节 (Least Significant Byte, LSB)** 存储在内存的**最低地址**处。后续字节按顺序存储在更高地址。
   - **记忆法**：可以理解为“低位在前”。
   - **例子**：对于同一个整数 `0x12345678`，在内存中从低地址到高地址的存储顺序是：`78 56 34 12`。
   - **应用**：题目中已指出，**Intel CPU** 使用小端模式。

**主要区别**：根本区别在于多字节数据的字节在内存地址中的排列顺序是相反的。大端将最高有效字节放在最低地址，小端将最低有效字节放在最低地址。

------

#### **(b) 确定8086如何以短实数格式存储实数值6.75。(5分)**

**核心概念**：8086的“短实数格式”通常指 **IEEE 754 单精度（32位）浮点数** 标准。该标准将32位分为三部分：1位符号位 (Sign)，8位指数位 (Exponent)，23位尾数位 (Mantissa/Fraction)。

1. **转换为二进制**：

   - 整数部分：6=4+2=1102
   - 小数部分：0.75=0.5+0.25=21+41=0.112
   - 合在一起：6.7510=110.112

2. **规格化**：将二进制数表示为 1.M×2E 的形式。

   - 110.112=1.1011×22

3. **确定符号、指数和尾数**：

   - **符号 (Sign)**：6.75是正数，所以符号位为 **0**。

   - 指数 (Exponent)

     ：指数是2。在单精度格式中，需要加上一个

     偏移量127

     。所以存储的指数为 

     2+127=129

     。

     - 将129转换为8位二进制：129=128+1=100000012。

   - 尾数 (Mantissa)

     ：尾数是规格化后小数点右边的部分，即 

     ```
     1011
     ```

     。必须用0补齐至23位。

     - 尾数部分为 `10110000000000000000000`。

4. **组合并转换为十六进制**：

   - 将三部分拼接：`0 10000001 10110000000000000000000`
   - 按4位分组：`0100 0000 1101 1000 0000 0000 0000 0000`
   - 转换为十六进制：`4 0 D 8 0 0 0 0`
   - 结果为 **`0x40D80000`**。

5. **按小端模式存储**：由于8086使用小端模式，这个32位的数值在内存中会以字节倒序存放。

   - 存储顺序为：`00 00 D8 40`。

------

#### **(c) 填写从1000h开始的内存内容。(8分)**

根据给出的汇编代码和Intel的小端规则，我们来填充内存：

- **`num dw 1025`**:
  - `dw` (Define Word) 定义一个字（2字节）。
  - `1025` (十进制) = `1024 + 1` = 4×256+1 = `0x0401`。
  - 小端存储：低字节 `01` 在低地址，高字节 `04` 在高地址。
  - 地址 `1000h` 存 `01h`，`1001h` 存 `04h`。
- **`num2 dd 6.75`**:
  - `dd` (Define Doubleword) 定义一个双字（4字节）。
  - 从(b)问可知，`6.75` 的32位浮点数表示为 `0x40D80000`。
  - 小端存储：`00 00 D8 40`。
  - 地址 `1002h` 到 `1005h` 分别存入 `00h`, `00h`, `D8h`, `40h`。
- **`num3 byte 770`**:
  - `byte` 定义一个字节（1字节），范围是0-255。
  - `770` 超出了一个字节的表示范围。在这种情况下，汇编器通常会报错或只取其**最低有效字节**。
  - `770` (十进制) = 3×256+2 = `0x0302`。
  - 最低有效字节是 `02h`。
  - 地址 `1006h` 存 `02h`。
- **`str byte '123abcD$'`**:
  - 定义一个字节字符串，每个字符存储为其ASCII码值。
  - '1'=`31h`, '2'=`32h`, '3'=`33h`, 'a'=`61h`, 'b'=`62h`, 'c'=`63h`, 'D'=`44h`, '$'=`24h`。
  - 从地址 `1007h` 开始依次存入。

**内存内容表**:

| **Offset Address** | **Memory Contents (Hex)** |
| ------------------ | ------------------------- |
| **100Eh**          | **24**                    |
| **100Dh**          | **44**                    |
| **100Ch**          | **63**                    |
| **100Bh**          | **62**                    |
| **100Ah**          | **61**                    |
| **1009h**          | **33**                    |
| **1008h**          | **32**                    |
| **1007h**          | **31**                    |
| **1006h**          | **02**                    |
| **1005h**          | **40**                    |
| **1004h**          | **D8**                    |
| **1003h**          | **00**                    |
| **1002h**          | **00**                    |
| **1001h**          | **04**                    |
| **1000h**          | **01**                    |

------

#### **(d) 8086寄存器是16位的，但地址总线是20位的。8086如何从16位寄存器生成数据、代码和堆栈的地址？(4分)**

**核心概念**：**分段内存管理机制 (Segmented Memory Architecture)**。

8086通过将内存划分为多个逻辑段（Segment）来解决16位寄存器寻址20位空间的问题。一个物理地址由两部分组成：

1. **段地址 (Segment Address)**：一个16位的值，存储在专门的段寄存器中（如 `CS` 代码段, `DS` 数据段, `SS` 堆栈段, `ES` 附加段）。它定义了一个64KB大小的内存段的起始基地址。
2. **偏移地址 (Offset Address)**：一个16位的值，也称为有效地址。它表示相对于段基地址的偏移量。这个值可以来自指令指针（IP）、通用寄存器（如BX, SI, DI）或指令中的立即数。

物理地址生成过程：

为了生成20位的物理地址，CPU内部的地址产生单元执行以下计算：

1. 将16位的**段地址**左移4位（相当于乘以16或`0x10`）。这会产生一个20位的段基地址，其末尾4位为0。
2. 将这个20位的段基地址与16位的**偏移地址**相加。

计算公式:

PhysicalAddress(20−bit)=(SegmentRegister×16)+OffsetAddress

或者

PhysicalAddress(20−bit)=(SegmentAddress≪4)+OffsetAddress

例子：如果数据段寄存器 DS 的值是 2000h，而指令要访问的偏移地址是 0150h，那么最终的物理地址是：

(2000h \ll 4) + 0150h = 20000h + 0150h = 20150h。

通过这种方式，8086能够利用其16位的寄存器访问高达1MB（220字节）的内存空间。

------

------

### **English Summary (Key Points)**

#### **(a) Big-Endian vs. Little-Endian**

- **Core Difference**: The byte order for multi-byte data in memory.
- **Big-Endian**: Stores the Most Significant Byte (MSB) at the lowest memory address. "Big end first."
- **Little-Endian**: Stores the Least Significant Byte (LSB) at the lowest memory address. "Little end first." Intel CPUs use this convention.

#### **(b) Storing 6.75 in Short Real Format**

- **Format**: IEEE 754 Single-Precision (32-bit).

- **Binary Conversion**: 6.7510=110.112.

- **Normalization**: 1.1011×22.

- Components

  :

  - **Sign**: 0 (positive).
  - **Exponent**: 2+127(bias)=129=100000012.
  - **Mantissa**: `1011` (padded to 23 bits).

- **Hex Representation**: `0x40D80000`.

- **Final Storage (Little-Endian)**: The bytes are stored as `00 00 D8 40`.

#### **(c) Filling Memory Contents**

The memory from `1000h` is filled based on assembly directives and the Little-Endian rule:

- **`dw 1025`**: `1025d` is `0x0401`. Stored as `01 04` at `1000h-1001h`.
- **`dd 6.75`**: `0x40D80000`. Stored as `00 00 D8 40` at `1002h-1005h`.
- **`byte 770`**: `770d` (`0x0302`) is out of range for a byte. Assuming truncation to the LSB, `02h` is stored at `1006h`.
- **`byte '123abcD$'`**: ASCII values (`31h, 32h, 33h, 61h, 62h, 63h, 44h, 24h`) are stored sequentially from `1007h`.

#### **(d) 20-bit Address Generation**

- **Mechanism**: The 8086 uses a **segmented memory model**.

- **Components**: A physical address is calculated from a 16-bit **segment address** (from CS, DS, SS, etc.) and a 16-bit **offset address**.

- Calculation

  :

  1. The 16-bit segment address is shifted left by 4 bits (multiplied by 16).
  2. The 16-bit offset address is added to the result.

- **Formula**: PhysicalAddress=(Segment≪4)+Offset. This allows 16-bit registers to access a 1MB (220) address space.





## Question4

好的，我们来解答这份关于8086 CPU中断机制的问题。

这份题目考察了计算机体系结构中的一个核心概念——中断（Interrupts）。它分为中断的类型、作用、处理过程以及硬件中断的扩展，这些都是理解现代计算机如何与外部设备高效交互的基础。

------

### **中文解析**

#### **(a) 这三种类型的中断之间有什么区别？(6分)**

8086 CPU的三种中断——硬件中断、软件中断和异常——其核心区别在于**中断源（Source）**、**触发方式（Triggering Mechanism）\**和\**用途（Purpose）**。

1. **硬件中断 (Hardware Interrupts)**

   - **中断源**：来自CPU外部的硬件设备，例如键盘、鼠标、硬盘控制器、定时器等。
   - **触发方式**：**异步 (Asynchronous)**。这意味着中断信号的到来与CPU当前正在执行的指令在时间上没有关系，是不可预测的。硬件设备在需要CPU为其服务时，通过CPU的物理引脚（如NMI或INTR）发送电信号来触发中断。
   - **用途**：主要用于处理外部I/O设备的请求，实现CPU与外设之间的并行工作，提高CPU利用率。例如，当你敲击键盘时，键盘控制器就会产生一个硬件中断，通知CPU读取你输入的字符。

2. **软件中断 (Software Interrupts)**

   - **中断源**：来自CPU内部，由正在执行的程序代码本身。
   - **触发方式**：**同步 (Synchronous)**。它是由一条特定的CPU指令——在8086中是 `INT n`（`n`是中断号）——主动触发的。因为是指令的一部分，所以它的发生时间和位置在程序中是确定和可预测的。
   - **用途**：主要用于程序向操作系统或BIOS请求服务。这是一种实现用户程序（用户态）与操作系统内核（内核态）之间通信的核心机制。例如，程序需要读写文件时，会调用一个包含 `INT 21h` (DOS系统调用)的函数来请求操作系统完成服务。

3. **异常 (Exceptions)**

   - **中断源**：同样来自CPU内部，是CPU在执行指令过程中遇到的错误或特殊情况。

   - **触发方式**：**同步 (Synchronous)**。它是在执行某条特定指令时，由于该指令本身的问题而“被动”产生的。

   - 用途

     ：用于处理程序运行时的错误。CPU检测到错误后，会强制中断当前程序，并跳转到相应的处理程序。常见的例子包括：

     - **除零错误 (Divide-by-zero)**：当CPU执行一条除法指令且除数为零时产生。
     - **溢出 (Overflow)**：算术运算的结果超出了目标寄存器能表示的范围。
     - **无效操作码 (Invalid Opcode)**：CPU试图执行一个不存在或非法的指令。

**总结区别表格**:

| **特性**     | **硬件中断**        | **软件中断**           | **异常**                 |
| ------------ | ------------------- | ---------------------- | ------------------------ |
| **中断源**   | 外部硬件设备        | `INT n` 指令           | 指令执行错误             |
| **触发方式** | 异步 (Asynchronous) | 同步 (Synchronous)     | 同步 (Synchronous)       |
| **可预测性** | 不可预测            | 可预测                 | 可预测（但非开发者意图） |
| **主要用途** | I/O设备服务         | 系统调用 (OS Services) | 错误处理                 |

------

#### **(b) 为什么中断对于CPU的正常运行是必要的？分别为硬件和软件中断各举一个功能例子。(4分)**

中断的必要性:

中断机制是现代计算机系统高效运行的基石。如果没有中断，CPU只能通过一种叫做轮询 (Polling) 的低效方式来与外部设备交互。轮询意味着CPU需要不断地、重复地去检查设备的状态（例如，“键盘有输入吗？”“打印机打印完了吗？”），这会极大地浪费CPU周期和计算资源。

中断机制将这种“主动检查”的模式变为了“被动等待”的模式：

1. **提高CPU效率**：CPU可以执行其他任务，只有在设备真正需要服务时才会被“中断”，从而处理请求。这使得CPU和外部设备可以并行工作，大大提高了系统的吞吐量和响应速度。
2. **实现实时响应**：对于需要立即处理的事件（如电源故障警告），中断可以确保CPU能够最快地做出反应。

**功能例子**:

- **硬件中断的功能**: **键盘输入**。当你按下一个键时，键盘控制器会向CPU发送一个硬件中断信号。CPU接收到中断后，会暂停当前工作，转而去执行一个特定的“中断服务程序”（Interrupt Service Routine, ISR），这个程序会从键盘的端口读取你按下的键的编码，并将其放入键盘缓冲区，供应用程序后续读取。
- **软件中断的功能**: **文件读写**。当一个应用程序需要从硬盘读取文件时，它不能直接操作硬盘硬件。它会使用一个软件中断（如DOS的 `INT 21h`）来请求操作系统提供服务。操作系统接管后，会验证请求的合法性，然后代表应用程序去执行底层的硬盘读写操作，完成后再将结果返回给应用程序。这保证了系统的安全和稳定。

------

#### **(c) 当中断发生时，简要解释CPU所采取的行动。(5分)**

当中断发生时，CPU会执行一系列固定的、自动化的步骤来保存当前状态并转而处理中断。这个过程大致如下：

1. **完成当前指令**：CPU会首先执行完当前正在处理的指令，以保证指令的完整性。
2. **压入标志寄存器 (Flags Register)**：CPU将包含当前状态（如进位、零标志等）的16位标志寄存器推入堆栈 (Stack)。这是为了在中断处理完成后能够恢复程序之前的状态。
3. **清零中断和陷阱标志位**：CPU会自动清除标志寄存器中的**中断允许标志位 (IF)** 和 **陷阱标志位 (TF)**。清除IF可以防止在处理当前中断时被其他可屏蔽的硬件中断再次打断（即“屏蔽中断”），保证当前中断服务程序的原子性操作。
4. **压入代码段寄存器 (CS)**：CPU将当前代码段寄存器 (CS) 的内容推入堆栈。
5. **压入指令指针寄存器 (IP)**：CPU将指令指针 (IP) 的内容（即下一条要执行指令的地址）推入堆栈。 *通过压入CS和IP，CPU就保存了中断发生时程序的返回地址。*
6. **加载新的CS和IP**：CPU根据中断号（Interrupt Number）从内存的**中断向量表 (Interrupt Vector Table, IVT)** 中获取新的CS和IP值。IVT位于内存的最低地址处（从`00000h`开始），它存储了所有中断服务程序（ISR）的入口地址。
7. **跳转并执行ISR**：CPU将从IVT中获取的新地址加载到CS和IP寄存器中，这使得CPU的执行流跳转到了对应的中断服务程序（ISR），并开始执行其中的代码。

中断服务程序的最后一条指令通常是 `IRET` (Interrupt Return)，它会执行上述过程的逆操作：从堆栈中弹出IP, CS, 和标志寄存器，从而使CPU返回到被中断的程序继续执行。

------

#### **(d) 8086上只有2个用于硬件中断的引脚，即NMI和INTR。解释8086如何允许来自两个以上外部源的中断，例如键盘、打印机和串行通信端口。(5分)**

8086 CPU本身确实只有两个硬件中断引脚，但它通过一个外部的、专门的芯片来管理和扩展中断源，这个芯片就是**可编程中断控制器 (Programmable Interrupt Controller, PIC)**，在当年的IBM PC中最常用的是 **Intel 8259A** 芯片。

其工作原理如下：

1. **集中管理中断请求**：像键盘、打印机、串行端口、定时器等多个外部设备不直接连接到CPU的INTR引脚，而是连接到8259A PIC的**中断请求 (IRQ - Interrupt ReQuest) 输入引脚**上。一个8259A芯片有8个IRQ输入引脚（IRQ0-IRQ7）。
2. **优先级判断与仲裁**：当一个或多个设备同时请求中断时，8259A会根据预设的**优先级**来决定哪个中断请求应该被优先处理。例如，通常键盘中断的优先级会高于打印机中断。
3. **向CPU发送中断信号**：在选择了优先级最高的中断请求后，8259A会向CPU的 **INTR** 引脚发送一个中断信号，告诉CPU“有一个设备需要服务”。
4. **提供中断号**：当CPU通过其**INTA (Interrupt Acknowledge)** 引脚回应中断请求时，8259A会将与该中断源对应的**中断号 (Interrupt Number / Vector Number)** 放在数据总线上，供CPU读取。
5. **级联扩展 (Cascading)**：如果8个中断源还不够用，还可以将多个8259A芯片**级联**起来。通常的做法是用一个“主”8259A，然后将另一个“从”8259A的输出连接到主芯片的一个IRQ引脚上。这样，一个主-从配置就可以管理多达 **15** 个不同的中断源（主芯片用掉一个引脚连接从芯片）。

通过这种使用外部PIC的方式，8086成功地将2个物理引脚扩展到了能够处理来自众多外部设备的硬件中断请求，实现了现代计算机所必需的I/O管理能力。

------

------

### **English Summary (Key Points)**

#### **(a) Difference between the three interrupt types**

- **Hardware Interrupt**: Triggered **asynchronously** by external devices (keyboard, timer). The timing is unpredictable. Used for I/O operations.
- **Software Interrupt**: Triggered **synchronously** by the `INT n` instruction within a program. It's a deliberate and predictable call for OS/BIOS services (system calls).
- **Exception**: Triggered **synchronously** by an error during instruction execution (e.g., divide-by-zero, invalid opcode). It's an unplanned event resulting from faulty code.

#### **(b) Why interrupts are necessary & examples**

- **Necessity**: Interrupts are crucial for CPU efficiency. They avoid **polling**, where the CPU wastes time constantly checking device status. Interrupts allow the CPU to perform other tasks and only handle a device when it actually needs service, enabling parallelism and fast system response.
- **Hardware Interrupt Function**: **Keystroke Handling**. A key press generates an interrupt, causing the CPU to run a routine to read the character from the keyboard.
- **Software Interrupt Function**: **File Access**. A program executes `INT 21h` (in DOS) to ask the OS to read a file from the disk on its behalf.

#### **(c) Actions taken by CPU when an interrupt occurs**

1. Finishes the current instruction.
2. Pushes the **Flags Register** onto the stack.
3. Clears the Interrupt Flag (IF) and Trap Flag (TF) to disable further maskable interrupts.
4. Pushes the **Code Segment (CS) Register** onto the stack.
5. Pushes the **Instruction Pointer (IP)** onto the stack. (This saves the return address).
6. Fetches the new CS and IP address of the Interrupt Service Routine (ISR) from the **Interrupt Vector Table (IVT)** based on the interrupt number.
7. Jumps to the new address and begins executing the ISR.

#### **(d) How 8086 handles more than two hardware interrupt sources**

The 8086 uses an external chip called a **Programmable Interrupt Controller (PIC)**, typically the **Intel 8259A**, to manage multiple interrupt sources.

- **Function**: Devices like keyboards and printers connect to the PIC's Interrupt Request (IRQ) lines, not directly to the CPU.
- **Arbitration**: The PIC prioritizes incoming requests from multiple devices.
- **Signaling**: When a valid interrupt occurs, the PIC signals the CPU via its single **INTR** pin.
- **Vectoring**: When the CPU acknowledges the interrupt, the PIC places the correct interrupt number on the data bus for the CPU to read.
- **Expansion**: Multiple PICs can be **cascaded** (a "slave" PIC connected to a "master" PIC) to manage up to 15 external devices.





## Question5

好的，我们来详细解答这份关于MOSFET、半导体物理和三态逻辑的综合问题。

这份题目涵盖了半导体器件的物理结构、导电原理以及在数字电路中的实际应用，是电子工程和计算机科学的基础。

------

### **中文解析**

#### **(a) 绘制一个n沟道MOSFET的结构图，并清晰地标出金属、氧化物、n型掺杂、p型掺杂和硅的部分。(5分)**

由于无法直接在此处绘图，我将用文字详细描述这个结构图的关键组成部分，您可以根据描述轻松地绘制出来。

n沟道增强型MOSFET (n-channel enhancement-mode MOSFET) 是最常见的类型。其结构图为一个横截面图：

1. **衬底 (Substrate)**：最基础的部分是一大块**p型掺杂的硅 (p-doped silicon)**。这是整个器件的基座，也称为体(Body)。请在图的下半部分画一个大的矩形区域并标记它。
2. **源极 (Source) 和 漏极 (Drain)**：在p型衬底的上表面，左右两侧分别制作出两个**n型掺杂的硅 (n-doped silicon)**区域。这两个区域就是源极和漏极。请在衬底上方的左右两侧画两个较小的矩形并标记它们。
3. **栅极氧化层 (Gate Oxide)**：在源极和漏极之间的p型衬底表面上，生长或淀积一层非常薄的绝缘层，这层通常是**二氧化硅 (Silicon Dioxide, SiO₂)**。它将下方的硅和上方的金属隔离开。请在源极和漏极之间的区域画一条细线并标记为**氧化物 (Oxide)**。
4. **栅极 (Gate)**：在氧化层的正上方，是一层导电材料，传统上是**金属 (Metal)**（如铝），现在更常用多晶硅(Polysilicon)。这个电极就是栅极。请在氧化层上方画一个矩形电极并标记为**金属 (Gate)**。
5. **金属接触电极**：最后，在源极、漏极和栅极的顶部，分别引出金属电极用于连接外部电路。

**总结一下结构的关键点**：

- 整个器件基于一块大的**硅 (Silicon)** 材料。
- 这块硅衬底是**p型掺杂 (p-doped)**的。
- 源极和漏极是**n型掺杂 (n-doped)**的。
- 栅极是**金属 (Metal)**。
- 栅极和硅衬底之间由一层薄的**氧化物 (Oxide)** 隔开。

当在栅极上施加一个正电压时，它会吸引p型衬底中的少数载流子（电子）到氧化层下方，形成一个导电的n型沟道，从而连接源极和漏极，使晶体管导通。

------

#### **(b) 根据载流子和能带理论，解释以下每种材料如何支持电流流动：(10分)**

**(i) 金属 (Metal)**

- **能带结构**：在金属中，**价带 (Valence Band)** 和 **导带 (Conduction Band)** 重叠在一起，或者导带只有部分被电子填充。这意味着价带和导带之间没有**能隙 (Bandgap)**。
- **载流子**：由于没有能隙，大量的电子（形成所谓的“电子海”）可以自由地在晶格中移动，它们只需要极小的能量（如电场提供的能量）就能从一个能级跃迁到另一个更高的能级，成为自由的**电荷载流子 (Charge Carriers)**。
- **导电性**：因此，金属中存在密度极高的自由电子，导电性非常强。

**(ii) 氧化物 (Oxide)**

- **能带结构**：氧化物（如二氧化硅SiO₂）是**绝缘体 (Insulator)**。其显著特征是拥有一个非常宽的**禁带 (Forbidden Band) 或能隙 (Bandgap)**，通常大于5电子伏特(eV)。
- **载流子**：价带中的电子被紧紧束缚在原子核周围，需要巨大的能量才能激发它们跨越宽能隙到达导带。在正常电压下，几乎没有电子可以成为自由载流子。
- **导电性**：由于缺乏自由移动的电荷载流子，氧化物几乎不导电，因此在MOSFET中被用作完美的绝缘层。

**(iii) n型掺杂硅 (n-doped Silicon)**

- **能带结构**：在纯硅中掺入五价元素（如磷、砷），这些杂质原子在硅的能带结构中，靠近导带底部的位置引入了一个**施主能级 (Donor Level)**。
- **载流子**：在室温下，施主能级上的电子很容易获得少量热能，被激发进入**导带**，成为自由电子。因此，**电子 (electrons)** 是主要的、多数的载流子（Majority Carriers）。同时，价带中也会有少量因热激发产生的空穴，为空穴（Holes）是少数载流子（Minority Carriers）。
- **导电性**：主要依靠导带中的大量自由电子来导电。

**(iv) p型掺杂硅 (p-doped Silicon)**

- **能带结构**：在纯硅中掺入三价元素（如硼），这些杂质原子在靠近价带顶部的位置引入了一个**受主能级 (Acceptor Level)**。
- **载流子**：价带中的电子很容易被激发到这个受主能级上，从而在**价带**中留下一个可以自由移动的**空穴 (hole)**。因此，**空穴**是多数载流子（Majority Carriers）。同时，也会有极少数的电子被热激发到导带，成为少数载流子（Minority Carriers）。
- **导电性**：主要依靠价带中的大量空穴的移动来导电（空穴的移动等效于电子向相反方向的运动）。

**(v) 纯硅 (Pure Silicon)**

- **能带结构**：纯硅（本征半导体）有一个中等大小的能隙（约1.12 eV）。
- **载流子**：在绝对零度时，价带被电子填满，导带为空，不导电。在室温下，一些电子获得足够的热能，可以从价带跃迁到导带，成为自由电子，并在价带中留下一个空穴。因此，**电子和空穴**的数量相等，但浓度非常低。
- **导电性**：导电能力很差，远不如掺杂后的半导体，但比绝缘体强。其导电性依赖于成对产生的电子和空穴。

------

#### **(c) 由CMOS反相器制成的三态设备是连接输入输出线到数据总线所必需的。解释这些三态设备如何工作，以及如果不使用它们会发生什么。(5分)**

三态设备的工作原理:

三态设备（或称三态缓冲器/驱动器）是一种特殊的数字逻辑门，它除了有标准的逻辑高电平（'1'）和逻辑低电平（'0'）两种输出状态外，还有第三种状态——高阻态 (High-Impedance, Hi-Z)。

它通常由一个标准的CMOS反相器和一个额外的**使能 (Enable, EN)** 控制输入端构成。

1. **输出高电平 ('1')**：当`EN`为高电平（使能状态）且输入为`0`时，三态设备的输出为高电平。此时，内部的上拉PMOS管导通，下拉NMOS管关闭，输出端被强连接到电源(Vdd)。
2. **输出低电平 ('0')**：当`EN`为高电平（使能状态）且输入为`1`时，三态设备的输出为低电平。此时，内部的下拉NMOS管导通，上拉PMOS管关闭，输出端被强连接到地(GND)。
3. **高阻态 (Hi-Z)**：当`EN`为低电平（禁用状态）时，无论输入是什么，三态设备的输出进入高阻态。此时，内部的**上拉PMOS管和下拉NMOS管同时被强制关闭**。输出端在电气上与电源(Vdd)和地(GND)都断开，就好像它从总线上“消失”了一样，对总线电压没有任何驱动能力。

不使用三态设备的后果:

数据总线（Data Bus）是一个共享的信道，许多设备（如内存、CPU、I/O设备）的输出端都连接到同一组物理线路上。

- 问题场景

  ：假设有两个普通（非三态）的设备A和B同时连接到同一条总线上。

  - 设备A想要输出一个高电平 '1' (即连接到Vdd)。
  - 设备B同时想要输出一个低电平 '0' (即连接到GND)。

- 后果：总线冲突 (Bus Contention / Bus Fighting)

  - 此时，总线会通过设备A的输出电路连接到电源(Vdd)，同时又通过设备B的输出电路连接到地(GND)。这相当于在**电源和地之间形成了一条低电阻的通路，即短路 (Short Circuit)**。
  - 这会产生巨大的电流，可能瞬间**烧毁**一个或两个设备的输出驱动器，甚至损坏电源。
  - 总线上的电压会处于一个不确定、无意义的中间状态，导致数据传输彻底失败。

**结论**：三态设备通过其“高阻态”功能，确保在任何时刻只有一个设备的输出在“驱动”总线，而其他所有设备都处于电气断开状态。这就像一个交通控制系统，保证了共享道路（总线）的安全和有序使用。

------

------

### **English Summary (Key Points)**

#### **(a) Sketch of an n-channel MOSFET structure**

- **Substrate**: A block of **p-doped silicon**.
- **Source/Drain**: Two regions of **n-doped silicon** embedded in the substrate surface.
- **Gate Oxide**: A thin layer of **Silicon Dioxide (SiO₂)**, an insulator, between the source and drain.
- **Gate**: A **metal** or polysilicon electrode on top of the gate oxide.
- **Operation**: A positive voltage on the gate creates an n-type channel in the p-substrate, connecting the source and drain.

#### **(b) How materials support current flow (Charge Carriers & Energy Bands)**

- **(i) Metal**: Conduction and valence bands **overlap** (no bandgap). A "sea" of **free electrons** acts as charge carriers, resulting in high conductivity.
- **(ii) Oxide (Insulator)**: A very **large bandgap**. Valence electrons are tightly bound, requiring huge energy to become free. Almost **no free charge carriers**.
- **(iii) n-doped Silicon**: Doping creates a **donor level** near the conduction band. **Electrons** are the majority carriers in the conduction band.
- **(iv) p-doped Silicon**: Doping creates an **acceptor level** near the valence band. **Holes** are the majority carriers in the valence band.
- **(v) Pure Silicon**: Has a moderate bandgap. An equal, but small, number of **electrons and holes** are thermally generated. Poor conductor compared to doped silicon.

#### **(c) Tri-state Devices and their necessity**

- Function

  : A tri-state device has three output states controlled by an 

  Enable (EN)

   pin:

  1. **HIGH ('1')**: Drives the output to Vdd (when EN is active).
  2. **LOW ('0')**': Drives the output to GND (when EN is active).
  3. **High-Impedance (Hi-Z)**: Both pull-up and pull-down transistors are turned **OFF** (when EN is inactive). The output is electrically disconnected from the bus.

- Consequence of Not Using Them

  : If multiple standard (non-tri-state) outputs are connected to a shared bus, a situation called 

  bus contention

   can occur.

  - **Scenario**: One device tries to output '1' (drives bus to Vdd) while another tries to output '0' (drives bus to GND).
  - **Result**: This creates a **short circuit** between power (Vdd) and ground (GND), leading to large currents, indeterminate bus voltage, and probable **physical damage** to the devices.