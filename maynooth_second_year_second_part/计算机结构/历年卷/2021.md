#### **(a) 题**

**问题**: 请说出图中方框 A, B, C, D, E 所示项目的名称。 

- A

  : 这是 

  目标代码 (Object Code)

   或 

  机器码 (Machine Code)

  。它显示了汇编指令被汇编器转换后的十六进制机器语言代码以及它们在内存中的地址。 

- B: 这是 

  程序段定义 (Program Segment Definition)

  。它包含了一些汇编器伪指令 (Assembler Directives)，如 

  ```
  .MODEL
  ```

  , 

  ```
  .STACK
  ```

  , 

  ```
  .CODE
  ```

   等，用于定义程序的内存模型、堆栈、数据段和代码段。 

- C: 这是 

  汇编语言指令 (Assembly Language Instructions)

  。它包含了程序的实际操作指令，例如 

  ```
  mov
  ```

  , 

  ```
  int
  ```

  , 

  ```
  cmp
  ```

   等，这些是CPU可以执行的操作的助记符 (Mnemonics)。 

- D: 这是 

  标签 (Labels)

  。例如 

  ```
  next:
  ```

  , 

  ```
  done:
  ```

  ，它们是代码中特定位置的标识符，主要用作跳转指令的目标地址。 

- 

  E

  : 这是 

  注释 (Comments)

  。这些是以分号 

  ```
  ;
  ```

   开头的文本，用于向阅读代码的人解释程序的功能，汇编器会忽略它们。 

------

#### **(b) 题**

**问题**: 汇编器伪指令 (assembler directives) 和汇编语言指令 (assembly language instructions) 的主要区别是什么？ 



- **核心区别**: 汇编语言指令是CPU要执行的操作的助记符，它们会被汇编器直接翻译成CPU可以执行的机器码。而汇编器伪指令是给汇编器看的指令，它指导汇编器如何组织程序、分配内存和定义数据，但通常不直接生成可执行的机器码。
- **举例**: `mov ax, bx` 是一条汇编指令，告诉CPU将BX寄存器的内容复制到AX寄存器。`.DATA` 是一条伪指令，告诉汇编器接下来的内容是需要分配在数据段中的数据定义。

------

#### **(c) 题**

**问题**: 当按键时，只有特定的字符会被显示。这些字符是什么？ 



- 通过分析代码逻辑可以确定显示字符的范围。程序首先读取一个字符，然后进行两次比较：
  1. `cmp dl, 041h` (`'A'`) 和 `jb next`：如果输入的字符的ASCII码小于 `'A'` (41h)，则程序会跳转到 `next` 处，不显示该字符。
  2. `cmp dl, 07Ah` (`'z'`) 和 `jnb next`：如果输入的字符的ASCII码大于或等于 `'z'` (7Ah)，则程序也会跳转，不显示该字符。
- 因此，只有ASCII码在 `41h` (包含 'A') 和 `7Ah` (不包含 'z') 之间的字符才会被显示在屏幕上。这个范围包括了所有大写字母 ('A' - 'Z')、所有小写字母 ('a' - 'y')，以及介于 'Z' 和 'a' 之间的几个特殊符号 (如 `[`, `\`, `]`, `^`, `_`, ```)。

------

#### **(d) 题**

**问题**: 地址 21h 和 2Bh 处的十六进制值已被替换为 XX 和 YY。请写出这些值。 



- 这道题要求计算相对跳转指令的偏移量。

- 计算 XX

  :

  - 指令是 `je done` (操作码 `74`)，位于地址 `0020h`。
  - 跳转目标 `done` 的地址是 `0032h`。
  - 相对偏移量是相对于下一条指令的地址计算的，即 `0022h`。
  - 偏移量 = 目标地址 - 下一指令地址 = `0032h - 0022h = 10h`。
  - 所以 **XX = 10**。

- 计算 YY

  :

  - 指令是 `jnb next` (操作码 `73`)，位于地址 `002Ah`。
  - 跳转目标 `next` 的地址是 `0017h` (这是一个向后的跳转)。
  - 下一条指令的地址是 `002Ch`。
  - 偏移量 = `0017h - 002Ch = -15h`。
  - 需要将 `-15h` 表示为8位的补码。`15h` 的二进制是 `0001 0101`。其补码为 `1110 1011`，即 `EBh`。
  - 所以 **YY = EB**。

------

#### **(e) 题**

**问题**: 当输入‘Q’来终止程序时，请解释它是否会在程序将控制权返回给操作系统之前被回显在屏幕上。 



- **不会被回显**。

- 代码的执行流程如下：

  1. `int 021h` (当 `ah=08h` 时) 读取一个字符'Q'到 `al` 寄存器，这个功能本身不会回显字符。

  2. `cmp dl, 'Q'` 指令比较输入是否为'Q'。

  3. 因为输入是'Q'，比较结果相等，所以 `je done` 指令的跳转条件成立。

  4. 程序会直接跳转到 `done:` 标签处，然后执行 `.EXIT` 退出。

  5. 用于回显字符的代码块（

     ```
     mov ah,02h
     ```

      和 

     ```
     int 021h
     ```

     ）被这个跳转完全跳过了。因此，'Q'不会被显示。 

------

#### **(f) 题**

**问题**: 双极结型晶体管 (BJT) 和结型场效应晶体管 (JFET) 都允许通过信号控制电流。请简要解释这两种器件在操作上的区别。 



- **BJT (双极结型晶体管)**: 是一种 **电流控制器件**。一个很小的基极电流 (Base Current, $I_B$) 控制着一个大得多的集电极-发射极电流 (Collector-Emitter Current, $I_C$)。它的导电过程涉及两种载流子：电子和空穴，因此被称为“双极”。
- **JFET (结型场效应晶体管)**: 是一种 **电压控制器件**。施加在栅极 (Gate) 上的电压 ($V_G$) 产生一个电场，这个电场改变了源极 (Source) 和漏极 (Drain) 之间沟道的导电能力，从而控制电流 ($I_D$)。它只利用一种载流子（N沟道用电子，P沟道用空穴），因此是“单极”的。

------

#### **(g) 题**

**问题**: 简要解释复杂指令集计算机 (CISC) 和精简指令集计算机 (RISC) 在操作上的差异，并各举一个优点。 



- CISC (复杂指令集)

  :

  - **操作**: 强调用一条指令完成复杂的任务。其指令集包含大量指令，指令长度可变，执行周期也不同。许多指令可以将内存读取、算术运算和内存写入等多个操作合并。
  - **优点**: 代码密度高，即完成一个任务所需的指令数较少，程序体积更小。这在早期内存昂贵的时代非常重要。

- RISC (精简指令集)

  :

  - **操作**: 强调指令的简洁和高效。只使用一小组简单、高度优化的指令。这些指令通常长度固定，并且大部分能在单个时钟周期内完成。复杂的任务由编译器将这些简单指令组合起来完成。
  - **优点**: 简单的指令格式便于实现指令流水线 (pipelining)，可以显著提高处理器的运行频率和性能。同时，更简单的硬件设计也降低了功耗和制造成本。

------

#### **(h) 题**

**问题**: 在系统设计过程中，微控制器和FPGA都可以使用。请简要解释为什么在为微波炉和洗衣机等大众消费产品制作原型时，FPGA比微控制器更受青睐。 



- **核心原因**: 这类大众消费产品的最终目标通常是生产一个 **ASIC (专用集成电路)**，以在海量生产中实现最低的成本和功耗。
- **FPGA (现场可编程门阵列)** 的作用是作为 **ASIC 的原型**。FPGA的硬件逻辑是可编程的，设计师可以在FPGA上实现并验证一个与最终ASIC功能完全相同的硬件电路。这使得在投入巨额资金进行ASIC流片（物理制造）之前，可以对硬件设计本身进行彻底的测试和迭代，从而极大地降低了项目风险。
- **微控制器 (Microcontroller)** 是一个固定的处理器，通过软件编程来执行任务。它能模拟最终产品的*行为*，但它无法验证最终ASIC的*硬件逻辑*。
- 因此，当最终目标是制造一个定制硬件芯片 (ASIC) 时，FPGA是首选的原型工具，因为它能够真正地在硬件层面进行设计和验证，是通往ASIC的理想桥梁。

------

### English Summary

Here is the concise answer in English for Question 1.

- **(a) Names of the boxed items:** 

  

  

  - A: Object Code / Machine Code 
  - B: Program Segment Definition 
  - C: Assembly Language Instructions (Mnemonics) 
  - D: Labels 
  - E: Comments 

- **(b) Difference between assembler directives and assembly instructions:** 

  

  

  - **Assembly instructions** (`mov`, `add`) are translated into machine code for the CPU to execute at runtime.
  - **Assembler directives** (`.MODEL`, `.DATA`) are commands for the assembler itself, guiding the assembly process (e.g., memory layout), and do not translate to executable CPU instructions.

- **(c) Characters that will be displayed:** 

  

  

  - The code displays characters whose ASCII values are greater than or equal to 

    ```
    0x41
    ```

     ('A') and less than 

    ```
    0x7A
    ```

     ('z'). 

     This range includes all uppercase letters (

    ```
    A-Z
    ```

    ), lowercase letters from 

    ```
    a
    ```

     to 

    ```
    y
    ```

    , and the symbols between 'Z' and 'a'.

- **(d) Hexadecimal values for XX and YY:** 

  

  

  - **XX**: The instruction is `je done` at `0020h`. The destination `done` is at `0032h`. The offset is relative to the next instruction's address (`0022h`). Offset = `0032h - 0022h = 10h`. So, **XX = 10**.
  - **YY**: The instruction is `jnb next` at `002Ah`. The destination `next` is at `0017h`. The offset is relative to `002Ch`. Offset = `0017h - 002Ch = -15h`. The 8-bit two's complement of `-15h` is `EBh`. So, **YY = EB**.

- **(e) Is ‘Q’ echoed when terminating?** 

  

  

  - No. When 'Q' is pressed, the 

    ```
    cmp dl, 'Q'
    ```

     instruction sets the zero flag, causing the 

    ```
    je done
    ```

     instruction to jump directly to the 

    ```
    done:
    ```

     label. 

    This jump bypasses the block of code responsible for echoing the character to the screen. 

- **(f) Difference in operation between BJT and JFET:** 

  

  

  - **BJT (Bipolar Junction Transistor)**: A **current-controlled** device. A small base current (IB) controls a large collector current (IC). It uses both electrons and holes as charge carriers.
  - **JFET (Junction Field-Effect Transistor)**: A **voltage-controlled** device. The gate voltage (VG) creates an electric field that modulates the channel's conductivity, thus controlling the drain current (ID). It has a very high input impedance.

- **(g) Differences between CISC and RISC:** 

  

  

  - CISC (Complex Instruction Set Computer)

    : Uses complex instructions that can perform multiple operations in a single instruction.

    - **Advantage**: High code density (smaller program size).

  - RISC (Reduced Instruction Set Computer)

    : Uses a small set of simple, fixed-length, and fast instructions.

    - **Advantage**: Simpler design allows for faster clock speeds and easier instruction pipelining, leading to higher performance and lower power consumption.

- **(h) Why are FPGAs preferred over microcontrollers for prototyping mass-consumer products?** 

  

  

  - Mass-consumer products often use a custom **ASIC (Application-Specific Integrated Circuit)** for lowest cost and power in mass production. An **FPGA (Field-Programmable Gate Array)** allows designers to build and test a hardware prototype that is functionally identical to the final ASIC. This de-risks the expensive process of ASIC fabrication. A microcontroller can only simulate the *behavior* in software, not prototype the final *hardware* circuit.









## Question2



您好，感谢您的提问。这是一个很好的观察，它触及了不同问题所考察的核心知识点。

经过仔细核对您提供的试卷，实际上**第五题 (Question 5) 并不要求计算短实数（short real value）**。

第五题的内容主要关于：

- 

  (a)

   中断的类型和CPU处理中断的过程 1

  。

- 

  (b)

   动态RAM (DRAM) 与静态RAM (SRAM) 的优缺点 2

  。

- 

  (c)

   计算一个硬盘驱动器 (HDD) 的总容量 3

  。

- 

  (d)

   固态硬盘 (SSD) 与HDD的优缺点 4

  。

您提到的关于“计算short real value”的部分，实际上是**第二题 (Question 2)** 的要求 5。



那么，**为什么第二题需要进行这个计算呢？**

原因在于第二题提供的汇编代码是为 **8087浮点协处理器 (FPU)** 编写的 6。



1. 

   协处理器专用指令

   : 这段代码使用了

   ```
   FLD
   ```

   , 

   ```
   FMUL
   ```

   , 

   ```
   FADD
   ```

   等指令，这些都是8087协处理器才能执行的浮点数运算指令 7

   。

2. 

   数据类型定义

   : 代码中的变量 

   ```
   SX
   ```

   , 

   ```
   SY
   ```

   , 和 

   ```
   SD
   ```

    被定义为 

   ```
   dd
   ```

    (define doubleword) 8

   ，并注释为 

   short real

    9

   。在x86汇编中，short real就是指

   4字节（32位）的单精度浮点数

   ，它遵循 IEEE 754 标准。

3. **题目要求**: 因此，为了验证代码的正确性（如第二题(a)部分）或预测其在给定输入下的输出（如第二题(c)部分），您必须将十进制数（如5.0或17.0）转换为协处理器实际使用的二进制格式，也就是IEEE 754短实数格式，并以十六进制显示。





