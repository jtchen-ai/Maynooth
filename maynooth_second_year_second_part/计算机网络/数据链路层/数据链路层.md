# 数据链路层

## 数据链路层的功能



- **封装成帧 (组帧)**
  - **帧定界**: 如何让接收方能够确定帧的界限。
  - **透明传输**: 接收方链路层要能从收到的帧内恢复原始SDU，让网络层“感受不到”将分组封装成帧的过程。
- **差错控制**
  - 发现并解决一个帧内部的“**位错**”。
  - **解决方案一**: 接收方发现比特错后**丢弃帧**，发送方**重传帧** (仅需采用**检错编码**)。
  - **解决方案二**: 由接收方发现并**纠正比特错误** (需采用**纠错编码**)。
- **可靠传输**
  - 发现并解决“**帧错**”。
  - **帧丢失**: eg: 发送帧`1` `2` `3` `4`，收到帧`1` `2` `4`。
  - **帧重复**: eg: 发送帧`1` `2` `3` `4`，收到帧`1` `2` `3` `3` `4`。
  - **帧失序**: eg: 发送帧`1` `2` `3` `4`，收到帧`1` `3` `2` `4`。
- **流量控制**
  - 控制发送方发送帧的速率别太快，让接收方来得及“接受”。
- **介质访问控制**
  - “**广播信道**”需要实现此功能。广播信道在逻辑上是总线型拓扑，多个结点需争抢信道介质的使用权。
  - “**点对点信道**”通常不需要实现此功能。点对点信道通常意味着两个结点之间有专属的传输介质，不用抢。

## 组帧 (封装成帧)





### 主要问题



- **帧定界**: 如何让接收方能够确定帧的界限。
- **透明传输**: 接收方要能够去除“帧定界”的附加信息，把帧“恢复原貌”。

------



### 字符计数法



- **方法**: 在每个帧开头，用一个定长计数字段来表示帧长。
- **注意**: 帧长 = 计数字段长度 + 帧的数据部分长度。
- **最大缺点**: 任何一个计数字段出错，都会导致后续所有帧无法定界（“帧同步”丢失）。



### 字节填充法



- **特殊字符**:
  - `SOH`: 标记帧开头的字符。
  - `EOT`: 标记帧结尾的字符。
  - `ESC`: 转义字符。
- **规则**: 如果帧的数据部分包含了`SOH`或`EOT`等特殊字符，发送方需要在这些字符前**填充一个转义字符(ESC)**。接收方则执行逆处理。



### 零比特填充法



- **帧定界符**: 用特殊的比特串 `01111110` 标记帧的开始和结尾。
- **发送方规则**: 对帧的数据部分进行处理，**每当遇到连续5个1，就填充一个0**。
- **接收方规则**: 对帧的数据部分进行处理，**每当遇到连续5个1，就删掉其后的0**。
- **应用**: HDLC协议、PPP协议均使用此方法。



### 违规编码法



- **方法**: 使用物理层不允许的“违规信号”来表示帧的开头和结尾（此方法需要物理层配合）。
- **示例**: 在曼彻斯特编码中，信号在每个比特的中间时刻都会发生跳变。可以利用“**中间不跳变**”的信号作为违规信号，来标记帧的开头和结尾。





## 奇偶校验





### 概念



- **信息位 (有效数据)**：指帧的“数据部分”。
- **校验位 (冗余位)**：为了给帧的“数据部分”进行检错/纠错而附加的一些冗余比特。



### 校验原理



- **方法**：在信息位的首部或尾部添加一个校验位。
- **奇校验**：要求整个校验码（信息位 + 校验位）中“1”的个数为**奇数**。
- **偶校验**：要求整个校验码（信息位 + 校验位）中“1”的个数为**偶数**。
- **能力**：奇偶校验码**仅能检测出奇数位错误，无纠错能力**。如果同时出现偶数个位的错误，则无法检测出来。



### 异或运算 (模二加)



- **规则**：两个比特进行异或运算，当二者“相异”时计算结果为1，相同时为0。
- **应用**：
  - 将“偶校验”编码中的所有位（信息位和校验位）进行异或运算。
  - 若最终结果为0，说明没有检测到错误。
  - 若最终结果为1，说明存在奇数位错误。



## 循环冗余校验码 (CRC)





### 构造过程



1. **确定除数**: 由一个**生成多项式**确定“除数”。若生成多项式中 `x` 的最高次为 `R`，则“除数”是一个 `R+1` 位的二进制数。
2. **构造被除数**: 将 `K` 个信息位后面拼接 `R` 个 `0`，作为“被除数”。
3. **执行除法**: 对“被除数”和“除数”进行**模二除法**（即异或运算），得到一个 `R` 位的余数。
4. **生成CRC码**: 最终的CRC码由 `K` 个信息位 + `R` 位余数构成。



### 校验过程



1. 接收方收到 `K+R` 位的CRC码后，将其作为被除数。
2. 使用与发送方相同的生成多项式（即“除数”）进行**模二除法**。
3. 检查计算出的余数：
   - **余数为 0**: 说明数据在传输过程中没有检测到错误。
   - **余数非 0**: 说明数据出错了。



### 检错与纠错能力



1. 可检测出所有**奇数个**比特的错误。
2. 可检测出所有**双比特**的错误。
3. 可检测出所有长度**小于等于校验位长度(R)**的连续错误（突发错误）。
4. 若选择合适的生成多项式，并且满足 2^R≥K+R+1 的条件，则可以**纠正单比特错误**。





## 海明码 (Hamming Code)





### 基本思想



- 通过**分组偶校验**的方式，利用多个校验位来共同**反映出单个错误比特的具体位置**。



### 求解步骤



1. **确定校验位数 (k)**
   - **公式**：设 `n` 为信息位的数量，`k` 为校验位的数量，则 `k` 必须满足不等式：2k≥n+k+1。
2. **确定校验位分布**
   - **校验位 (P)**：将校验位 P1,P2,P3,… 依次放在海明码中第 1,2,4,8,… (即 20,21,22,23,…) 的位置上。
   - **信息位 (D)**：将原始信息位依次填入海明码中余下的其他位置。
3. **求校验位的值**
   - **分组**：对于每一个校验位 Pi，其校验的数据是所有位置序号的二进制表示中第 `i` 位为 `1` 的那些位。
   - **计算**：对每个分组执行**偶校验**，使得分组中所有 `1` 的个数为偶数，从而确定每个 Pi 的值（`0` 或 `1`）。
4. **纠错**
   - 接收方对收到的数据重新按上述规则进行分组，并计算每个分组的偶校验值，得到纠错码 Sk…S2S1。
   - **若 Sk…S2S1=00…0**：说明无错误。
   - **若 Sk…S2S1=00…0**：其**十进制值**就指明了出错比特的位置，将该位置的比特取反即可完成纠错。



### 补充



- **基本能力**：标准的海明码具有**纠正1位错误**的能力。
- **增强能力 (检2位错)**：为了能够区分“1位错误”和“2位错误”，可以在原始海明码的基础上额外**增加1位“全校验位”**。这位全校验位对海明码的**所有位**进行偶校验。
  - 如果全校验位和纠错码都指示有错，说明是1位错误，可纠正。
  - 如果全校验位指示有错，但纠错码为0，说明是2位错误，不可纠正。
- **注意**：不同题目中，海明码的位置编号可能从左到右，也可能从右到左，但核心处理方法是相同的。







## 停止-等待协议 (S-W)



- **滑动窗口机制**
  - 发送窗口 WT=1
  - 接收窗口 WR=1
- **确认机制**
  - **确认帧**: `ACK_i`
  - **规则**: 若接收方成功接收到 `i` 号帧，且没有检测出“差错”，就需要向发送方返回确认帧 `ACK_i`。
- **重传机制**
  - **超时重传**: 若发送方在设定的超时时间内仍未收到 `ACK_i`，则会重新发送 `i` 号帧。
- **帧编号**
  - **需求**: 仅需 **1 bit** 即可为“帧”编号（通常为0和1）。
  - **协议要求**: 必须满足 WT+WR≤2n (n为编号比特数)，对于S-W协议，1+1≤21，符合要求。



### 回顾



- **S-W 如何实现流量控制？**
  - **核心问题**: 在什么情况下发送窗口、接收窗口会“滑动”？
    - **发送方**: 只有收到了对方的确认帧ACK后，发送窗口才会向前滑动（准备发送下一个帧）。
    - **接收方**: 只有成功接收并向上层交付数据后，接收窗口才会向前滑动（准备接收下一个帧）。
  - 这种“发一帧、等一帧”的机制，自然地控制了发送方的速率，使其不会超过接收方的处理能力。
- **S-W 如何实现可靠传输？**
  - **如果数据帧丢失，收/发双方会发生什么？**
    - 接收方收不到数据，什么也不做。发送方等待ACK超时后，会重传数据帧。
  - **如果接收方检测出数据帧有“差错”并将其丢弃，会发生什么？**
    - 同上。接收方丢弃差错帧，发送方等待ACK超时后，会重传数据帧。
  - **如果收到重复数据帧，收/发双方会怎么做？**
    - 接收方发现收到的帧编号与期望的不符（是已接收过的帧），会丢弃该重复帧，并重新发送一次对该帧的确认ACK。
  - **为什么S-W不存在“数据帧失序”问题？**
    - 因为发送方一次只发送一个帧，只有在前一个帧被确认后，才会发送下一个。这种严格的串行顺序确保了数据帧永远不会失序到达。





## 后退N帧协议 (GBN)



- **滑动窗口机制**
  - 发送窗口 WT>1
  - 接收窗口 WR=1
- **确认机制**
  - **确认帧**: `ACK_i`
  - **规则**: 若接收方成功接收到 `i` 号帧且无差错，则返回确认帧 `ACK_i`。
- **重传机制**
  - **超时重传**: 若发送方在超时后仍未收到对 `i` 号帧的确认，则重传 `i` 号帧。
- **帧编号**
  - 为了支持以上机制正确运行，至少需要用 `n` bit为帧编号。
  - **协议要求**: 必须满足 WT+WR≤2n。

------



### GBN的特殊规则



- **关于确认帧 (累积确认)**
  - 接收方可以采用“**累积确认**”机制。即当连续收到多个正确的数据帧时，可以仅返回对最后一个帧的确认 `ACK`。
  - 一个 `ACK_i` 的成功返回，表示接收方**已正确收到了 `i` 号帧以及它之前的所有帧**。
- **关于超时重传 (后退N)**
  - 若发送方超时仍未收到对 `i` 号帧的确认，则需要**重传 `i` 号帧以及在它之后所有已发送的帧**。



### 要点



- **处理非法帧**
  - 当接收方收到一个“**非法帧**”时，会将其直接丢弃，并**重新发送一次目前已确认的最后一个正确帧的确认** `ACK_j`。这会提醒发送方从 `j+1` 号帧开始重新发送。
  - **注**: “非法帧”包括落在接收窗口之外的帧（即失序帧）和检测出差错的帧。
- **缺点**
  - 如果信道质量差（误码率高）或网络拥塞，会导致频繁的“后退”重传。即使某些帧已正确到达接收方，它们也可能因为前面的帧出错而被重传，从而导致传输效率低下。





## 选择重传协议 (SR)



- **滑动窗口机制**
  - 发送窗口 WT>1
  - 接收窗口 WR>1
- **确认机制**
  - **确认帧 (ACK)**: `ACK_i`
  - **规则**: 若接收方正确无误地收到了 `i` 号帧，则需要向发送方返回一个对 `i` 号帧的确认 `ACK_i`。
- **否认机制 / 差错处理**
  - **否认帧 (NAK)**: `NAK_i`
  - **规则**: 若接收方收到 `i` 号帧，但检测出该帧有“差错”，则需要丢弃该帧，并向发送方返回一个否认帧 `NAK_i`，主动请求重传。
- **重传机制**
  - **超时重传**: 若发送方在规定时间内未收到对 `i` 号帧的 `ACK_i`，则会重新发送 `i` 号帧。
  - **请求重传**: 若发送方收到了 `NAK_i`，则会立即重新发送 `i` 号帧。
- **帧编号**
  - **需求**: 为了支持协议正确运行，至少需要用 `n` bit为帧编号。
  - **协议要求**:
    - WT+WR≤2n
    - WR≤WT (接收窗口大小不能超过发送窗口大小)
    - *通常为了最大限度利用序号，会设 WT=WR=2n−1*



### 要点



- **主动请求重传**: SR协议的一个特点是，接收方在检测到帧差错时，会通过发送`NAK`帧来主动请求重传，而不是像GBN一样被动等待。
- **单个确认**: 接收方**不能“累积确认”**，必须对每一个正确接收的帧进行**逐一确认**（“一帧一确认”），以便发送方能准确了解哪些帧丢失或出错了。