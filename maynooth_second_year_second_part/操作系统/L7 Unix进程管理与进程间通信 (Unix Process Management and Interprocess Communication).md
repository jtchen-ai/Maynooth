# L7 Unix进程管理与进程间通信 (Unix Process Management and Interprocess Communication)

* **Unix 进程管理 (Unix Process Management)**
    * **进程创建 (Process Creation)**
        * **`fork()` 系统调用**:
            * 用于在C程序中创建一个新进程。
            * 每个进程都有一个唯一的ID。
            * 初始进程是父进程 (Parent)，新进程是子进程 (Child)。
            * 子进程是父进程的精确副本，包括父进程I/O描述符表的副本，因此它继承了对父进程所有打开的I/O设备的访问权限。
            * `fork()` 调用后，父进程和子进程都存在，并执行相同的代码副本，但`pid`值不同。
        * **`exec()` 系统调用**:
            * 通常由子进程在 `fork()` 之后使用。
            * `exec()` 将指定的二进制文件加载到进程的内存中（替换现有的程序映像）并开始执行它。
        * **`wait()` 系统调用**:
            * 调用 `wait()` 会暂停调用进程的执行，直到其某个子进程终止。
            * 成功时，返回已终止子进程的进程ID；失败时，返回-1。
            * 系统在执行 `wait()` 后会回收僵尸子进程 (zombie child) 的资源。
            * **僵尸进程**: 当一个子进程退出后，系统会保留其pid和终止状态等信息，直到父进程执行 `wait()`。
        * **C程序示例**:
            * 程序模板包含 `<stdio.h>`, `<unistd.h>`, `<stdlib.h>` 等头文件。
            * 命令行参数通过 `argc` (参数数量) 和 `argv` (参数字符串数组) 传递给 `main` 函数。
            * 示例代码展示了如何使用 `fork()` 创建子进程，父进程如何使用 `wait(NULL)` 等待子进程完成，以及子进程如何使用 `execlp()` 执行新命令。
    * **Linux 启动顺序 (The Linux Boot Sequence)**
        * **启动流程**:
            * 1. **开机/重启与固件初始化**: 系统启动和硬件初始化 (BIOS)。
            * 2. **主引导记录 (MBR)**: 固件选择第一个启动设备，并从该设备读取MBR。MBR包含初始引导代码和活动分区信息。它总是位于磁盘的第一个扇区。
            * 3. **Boot Loader (GRUB)**: MBR代码加载主引导加载程序（如GRUB），它会显示一个菜单让用户选择要启动的操作系统。
            * 4. **内核启动与init进程**: 内核启动第一个进程 `init`。`init` 进程的 `pid` 为 1。
            * 5. **运行级别 (Run Levels)**: `init` 的主要作用是根据 `/etc/inittab` 文件中存储的配置信息，依据所选的运行级别来创建进程。
            * 6. **用户登录**: `init` 启动 `getty` 进程，最终显示用户登录提示符。
        * **Linux 运行级别 (Run Levels)**:
            * **0 (Halt)**: 关闭所有服务，系统不重启。
            * **1 (Single User)**: 用于系统维护，无网络功能。
            * **2 (No Network Support)**: 用于维护和系统测试。
            * **3 (MultiUser Network Support)**: 用于服务器系统的非图形文本模式操作。
            * **4 (Custom Mode)**: 由系统管理员使用的自定义模式。
            * **5 (Graphical X11)**: 图形化登录，具有与级别3相同的功能。
            * **6 (Reboot)**: 关闭所有服务并重启系统。

* **进程间通信 (Interprocess Communication - IPC)**
    * **定义与目的**:
        * 指的是独立的可调度任务之间交换或共享信息。
        * **原因**:
            * 数据并行化以加速计算。
            * 应用程序内的模块化、流水线化或分层功能划分（微服务）。
            * 客户端使用网络上的服务。
    * **基本实现方式**:
        * 1. 利用所有通信方都可访问的**共享内存区域**。
        * 2. 使用操作系统通信子系统提供的显式**消息传递**原语。
    * **共享内存通信 (Shared Memory Communication)**
        * **机制**:
            * 通常，独立进程可访问的地址空间是独立的。
            * 共享内存通信需要进程使用操作系统在它们之间建立一个共享的内存区域。
        * **特点**:
            * 通信通常要求进程在同一主机上。
            * 适用于愿意共享内存的协作进程。
            * 通过读/写操作进行隐式通信，效率高，无通信协议。
            * 需要同步机制。
    * **消息传递 (Message Passing)**
        * **机制**:
            * 适用于不能访问彼此地址空间的独立进程，这些进程可能互不信任且位于不同主机上。
            * 是一种中介性的操作系统机制，能将数据从一个进程的地址空间取出并放入另一个进程可访问的区域。
            * 最简单的形式必须实现两个基本原语：`send` 和 `receive`。
        * **设计问题 (Design Issues)**:
            * **命名 (Naming)**:
                * 如何在两个进程之间建立链接？
                * 发送方可以指定一个进程ID或一个邮箱/端口ID作为目标。
                * 涉及直接与间接通信，单通道与多通道的选择。
            * **同步 (Synchronisation)**:
                * `Send` 和 `Receive` 操作可以是阻塞式或非阻塞式的。
                * **阻塞式发送**: 发送进程被阻塞，直到消息被传递给接收进程或邮箱。
                * **非阻塞式发送**: 发送进程发送消息后可立即继续其他任务。
                * **阻塞式接收**: 接收方等待直到收到消息。
                * **非阻塞式接收**: 接收方要么获得可用消息，要么从`Receive`原语获得一个空值。
            * **缓冲 (Buffering)**:
                * 实现非阻塞语义需要缓冲。
                * 链接可以有零容量、有限容量或无限容量。
                * 缓冲增加了复杂性和对消息排序的需求。
            * **消息参数 (Message Parameters)**:
                * 消息包可以是固定大小或可变大小，可以是类型化或非类型化的。
                * 固定大小的消息更容易缓冲和管理带宽。
            * **可靠性与安全 (Reliability & Security)**:
                * 机制必须处理网络通信中的问题，如消息丢失和错乱，以及安全问题。
                * 一个可靠的传输协议会使用序列号和超时/确认/重传机制来确保消息序列正确到达。
                * 在公共网络上，通常需要对消息进行加密（如使用SSL），以确保只有通信方可以读取它们。