# 死锁 (Deadlocks)

* **死锁基础 (Deadlock Fundamentals)**
    * **定义 (Definition)**: 一组进程处于死锁状态，指的是该集合中的每个进程都在等待一个只能由该集合中另一个进程才能引发的事件。
    * **分析模型 (Model for Analysis)**:
        * 环境是一个多道程序环境，其中存在对有限数量资源的竞争。
        * **资源 (Resource)**: 线程/进程为继续执行而需要获取的任何类型的非共享对象。
            * 资源被分为不同类型，每种类型可能有多个实例。
            * 每个资源类型都可以关联一个等待进程/线程的队列。
            * 一个类别内的所有资源都是等效的，对该类别中资源的请求可以由任何可用实例来满足。
    * **资源利用协议 (Resource Utilisation Protocol)**:
        * **请求 (Request)**: 如果资源实例不可用，则请求进程必须等待。例如 `open()`, `malloc()`, `acquire()`。
        * **使用 (Use)**: 进程使用资源实例。
        * **释放 (Release)**: 完成后释放资源。例如 `close()`, `free()`, `release()`。
    * **死锁的四个必要条件 (Four Necessary Conditions)**:
        * **互斥 (Mutual Exclusion)**: 至少有一个资源必须以非共享模式持有。
        * **占有并等待 (Hold and Wait)**: 一个进程必须至少持有一个资源，并等待更多的资源。
        * **无抢占 (No Preemption)**: 资源不能被抢占；只有在进程自愿释放后才能释放资源。
        * **循环等待 (Circular Wait)**: 必须存在一个等待进程集合 {P₀, P₁, ..., Pₙ}，使得P₀等待P₁持有的资源，P₁等待P₂的资源，...，Pₙ等待P₀持有的资源。
    * **程序员的责任 (Programmer's Responsibility)**:
        * 程序员有责任通过正确使用同步机制和适当的资源分配策略，来确保共享应用程序管理资源的线程无死锁执行。
        * 操作系统通常无法检测其自身资源之外的死锁，例如，无法检查Java虚拟机内的死锁。

* **死锁表示与识别 (Deadlock Representation and Identification)**
    * **资源分配图 (Resource Allocation Graph)**:
        * 描述了进程和资源系统的快照。
        * **矩形** 代表资源类型，其中的**点**代表该类型的实例。
        * 从**进程到资源**的边表示进程正在等待获取该类型的资源。
        * 从**资源实例到进程**的边表示该进程已被分配并持有该资源实例。
    * **识别死锁 (Identifying Deadlock)**:
        * 只有当图中包含一个**环路 (cycle)** 时，才可能存在死锁。如果没有环路，系统则没有死锁。
        * 可以通过软件算法检测环路。
        * 存在环路**不是**死锁的保证，但它是死锁可能性的必要条件。
        * 环路可能存在，但环路外的进程可能会释放资源，从而打破环路。

* **处理死锁的方法 (Methods for Handling Deadlock)**
    * **1. 确保系统永不进入死锁 (Ensure system never enters deadlock)** 
        * **1.1 死锁预防 (Deadlock Prevention)**:
            * 通过约束资源请求的方式，确保至少一个必要条件不成立。
            * **破坏互斥**: 对于非共享资源来说通常不可行。
            * **破坏占有并等待**: 要求进程一次性请求所有资源，或在请求更多资源前释放已有资源。这可能导致需要大量或热门资源的进程饿死。
            * **破坏循环等待**: 强制进程按预定义的数字顺序请求资源。
            * **后果**: 这些请求限制通常会导致较低的设备利用率和系统吞吐量。
        * **1.2 死锁避免 (Deadlock Avoidance)**:
            * 系统需要关于进程生命周期内资源需求的额外信息。
            * 只有在保证存在一个安全序列，使得所有进程都能完成执行的情况下，系统才会谨慎地分配资源。
            * **银行家算法 (Banker's Algorithm)**:
                * 每个进程声明其可能需要的每种资源类型的最大数量。
                * 系统检查是否存在一个**安全序列 (safe sequence)** <P₁, P₂, ..., Pₙ>，对于每个Pᵢ，它将来可能请求的资源可以由当前可用资源加上所有Pⱼ（其中j<i）持有的资源来满足。
                * 如果不存在这样的序列，系统就处于**不安全状态 (unsafe state)**，这不一定是死锁，但容易发生死锁。
                * **示例**: 通过一步步检查，可以找到一个安全序列 <P₁, P₃, P₄, P₂, P₀>，证明系统是安全的。
    * **2. 允许系统进入死锁然后恢复 (Allow system to enter deadlock and then recover)** 
        * **死