# L5进程调度 III: 多处理器及其他系统 (Process Scheduling III: Multiprocessors and other systems)

* **多处理器系统调度 (Scheduling on Multiprocessor Systems)**
    * **性能问题 (Performance Issues)**
        * 使用更多处理器是提高系统总吞吐量的明显方法，但将处理器数量加倍通常不会使性能加倍。
        * 调度问题更为复杂，没有单一的最佳解决方案能优化所有情况下的处理器利用率。
        * 对总线、I/O、共享内存、操作系统代码的争用以及维护缓存一致性都可能导致性能滞后。
    * **队列组织 (Queue Organisation)**
        * 多处理器系统可以由异构（heterogeneous）或同构（homogeneous）的处理器集合组成。
        * 对于同构处理器，可以由所有处理器服务一个单一的任务队列。
        * 一个同构系统可以使用非对称或对称多处理。
        * **模型对比**:
            * **系统 A (银行模型)**:
                * 将队列合并为由 n 个处理器服务的单个队列。
                * 蛇形队列（Serpentine queues）常用于银行、售票处，其中的柜员执行对称多处理。
                * 平均周转时间公式为 $T_1 = \frac{1}{n\mu - n\lambda} = \frac{T}{n}$，这意味着平均周转时间更快。
            * **系统 B (超市模型)**:
                * 采用多个队列，每个处理器有自己的队列。
                * 由于队列空间和移动时间的物理限制，超市结账时会使用多个队列。
                * 每个处理器的平均周转时间公式为 $T = \frac{1}{\mu - \lambda}$。

* **排队论 (Queuing Theory)**
    * **定义**: 对等待线或队列的研究。
    * **目标**: 最大化吞吐量和减少排队时间是许多现实世界服务（不仅仅是计算机系统）的共同目标。排队论、建模和仿真的目的是帮助服务管理者以最佳方式组织系统。
    * **建模的关键要素**:
        * 任务的到达模式及其性质。
        * 任务如何排队和分派。
        * 服务的处理能力。
    * **到达模式 (Arrival Pattern)**
        * 现实世界中，顾客可能通过预约、成群到达或在特定时间到达。
        * 在计算机系统中，任务的到达模式可能是随机的，单个独立任务一次一个地到达。
        * **泊松分布 (Poisson Distribution)**: 可用于对随机到达过程进行建模，以找出在给定时间段内特定数量任务到达的概率。
            * $\lambda$ (lambda) 被指定为在一个区间内的平均事件数。
            * 观察到 k 个事件的概率由公式 $P(k \text{ events in interval}) = \frac{\lambda^k e^{-\lambda}}{k!}$ 给出。
    * **排队与分派策略 (Queuing and Dispatch Policy)**
        * 可能存在多个队列，如VIP或快速通道优先队列，或者其他类型的分类（异构性）。
        * 在模型中，我们假设所有计算任务都能被队列容纳，并且会留在系统中直到完成，忽略了现实世界中顾客可能因队列太长而放弃（Balk）或等待过久而离开（Jockey）等行为。
    * **服务系统 (The Service System)**
        * 服务时间可能是固定的，也可能遵循某种分布模式，例如**指数概率分布 (Exponential Probability Distribution)**。
        * **服务率 $\mu$** 描述了在特定时间段内预期被服务的任务数量。
        * **服务时间**是服务率的倒数。例如，如果服务率为5个任务/秒，则服务时间为0.2秒/任务。
    * **Little's Law 应用**:
        * 假设泊松到达和指数服务分布，如果系统平均到达率为 $\lambda$，服务率为 $\mu$，则平均周转时间 T 的公式为 $T = \frac{1}{\mu - \lambda}$。
        * 为了系统能够应对负载，$\mu$ 必须大于 $\lambda$。

* **其他调度环境 (Other Scheduling Environments)**
    * **分布式系统 (Distributed Systems)**
        * **定义**: 由局域网连接的一组物理上分散的计算机系统。
        * **调度目标**: 分布式操作系统会尽力监控和共享或平衡每个处理节点的负载。
        * **复杂性**:
            * 调度更为复杂，因为系统信息通常不集中在一处，而是在网络中的独立节点上管理。
            * 算法必须通过网络上的消息交换来收集决策所需的信息并传输控制信息。
            * 消息通信可能会因损坏、丢失或繁忙的调度模式而延迟，导致分布式算法的复杂性增加。
    * **实时系统 (Real Time Systems)**
        * **定义**: 为特定的工业过程控制应用而设计的计算机系统，具有明确定义的、固定的时间限制。处理必须在这些限制内完成，否则系统可能会失败。
        * **类型**:
            * **硬实时系统 (Hard Real Time Systems)**: 要求在保证的时间内完成关键任务。任务的代码执行时间需要在被调度器接受前进行分析。
            * **软实时系统 (Soft Real Time Systems)**: 尽力满足调度截止日期，但偶尔错过截止日期是可以容忍的。这可以通过给予关键进程更高且不随时间降级的优先级来实现。
        * **关键要求**:
            * **低分派延迟 (Dispatch Latency)**: 为确保实时进程能快速开始执行，分派延迟必须很小。
            * **可抢占的系统调用**: 这要求操作系统本身可以被抢占，如果一个更高优先级的实时进程想要运行时。
        * **专用调度算法**:
            * **最早截止期优先 (Earliest Deadline First - EDF)**: 就绪队列按截止期排序，调度程序首先服务于最紧急的任务。
            * **最低松弛度算法 (Least Laxity Algorithm)**: 选择剩余时间最少的进程。如果一个进程需要200毫秒并在250毫秒内完成，其松弛度为50毫秒。该算法在事件非周期性发生的情况下可能效果更好。